/*
 * Macros for easy callbacks for the Fast Light Tool Kit (FLTK).
 *
 * Copyright 2023 by Bill Spitzak and others.
 *
 * This library is free software. Distribution and use rights are outlined in
 * the file "COPYING" which should have been included with this file.  If this
 * file is missing or damaged, see the license at:
 *
 *     https://www.fltk.org/COPYING.php
 *
 * Please see the following page on how to report bugs and issues:
 *
 *     https://www.fltk.org/bugs.php
 */

#ifndef _FL_FL_CALLBACK_MACROS_H_
#define _FL_FL_CALLBACK_MACROS_H_

#include <stdlib.h>

/**
 \file fl_callback_macros.H
 This file provides macros for easy function and method callbacks
 with multiple type safe arguments.
*/

#ifdef FL_DOXYGEN

/**
 \brief Declare a C function callback with custom parameters.

 You can declare a plain C function callback or a static method callback with
 custom parameters using this macro. It simplifies the process of calling
 arbitrary functions with up to five custom parameters. The macro generates
 code that ensures type safety and expands FLTK's standard callbacks, which
 are limited to a single `void*` or `long` argument.

 To use the macro, you provide the widget that will handle the callback as the
 first argument. The second argument can be either a regular function or a
 static method in any class. After that, you can include up to five triplets,
 where each triplet consists of a type, a parameter name, and a value.

 For example, you can use `int, x, 3` to specify an integer parameter with a
 value of 3. If you need to pass two arguments, you can use two triplets
 like this: `int, x, 3, int, y, 4`, etc. .

 Whenever the code generated by the macro is called, the custom parameters are
 duplicated and marked for automatic deallocation using `delete` when the
 callback widget is destroyed.

 \code{.cpp}
 #include <FL/fl_callback_macros.H>
 ...
 Fl_Button *btn1 = new Fl_Button(10, 10, 100, 20, "Beep");
 FL_FUNCTION_CALLBACK(btn1, fl_beep);
 ...
 Fl_Button *btn2 = new Fl_Button(10, 40, 100, 20, "Hello");
 FL_FUNCTION_CALLBACK(btn2,
   fl_message,
   const char *, text, "Hello\n%d %d %d %d",
   int, a, 1,  int, b, 2,  int, c, 3,  int, d, 4
 );
 \endcode

 You can find a small demonstration program showcasing the usage of
 `FL_*_CALLBACK` in the `examples/callbacks.cxx` file.

 \param WIDGET the widget that will call the callback
 \param FUNC a C/C++ function or a static class method
 \param ... a list of zero to five triplets, each declaring a type, name, and value

 \see FL_METHOD_CALLBACK, FL_INLINE_CALLBACK
 */
#define FL_FUNCTION_CALLBACK(WIDGET, FUNC, ...)

/**
 \brief Declare a non-static class method callback with custom parameters.

 You can declare a callback for a non-static class method with custom parameters
 using this macro. It provides a convenient way to call arbitrary methods in
 any class, overcoming FLTK's limitation of passing only a single `void*` or
 `long` argument. Furthermore, it ensures type safety.

 The first argument of the macro specifies the widget that will handle the
 callback. The second argument indicates the class type to be called. The
 third argument must be a pointer to an instance of that class. Finally, the
 fourth argument is the name of the method within the class. That method must be
 public and not static.

 Following these arguments, you can include up to five triplets, where each
 triplet consists of a type, a parameter name, and a value. For example,
 `int, x, 3` specifies an integer parameter with a value of 3. If you need to
 pass two arguments, you can use two triplets, like this:
 `int, x, 3, int, y, 4`.

 Whenever the code generated by the macro is called, the custom parameters are
 duplicated and marked for automatic deallocation using `delete` when the
 callback widget is destroyed.

 \code{.cpp}
 #include <FL/fl_callback_macros.H>
 ...
 Fl_Button *btn = new Fl_Button(10, 10, 100, 20, "Test");
 FL_METHOD_CALLBACK(btn, Fl_Button, btn, color, Fl_Color, c, FL_GREEN);
 \endcode

 You can find a small demonstration program showcasing the usage of
 `FL_*_CALLBACK` in the `examples/callbacks.cxx` file.

 \param WIDGET the widget that will call the callback
 \param CLASS the class type
 \param SELF a pointer to an instance of the class
 \param METH a C++ class method that must be public and not static
 \param ... a list of zero to five triplets, each declaring a type, name, and value

 \see FL_FUNCTION_CALLBACK, FL_INLINE_CALLBACK
 */
#define FL_METHOD_CALLBACK(WIDGET, CLASS, SELF, METH, ...)

/**
 \brief Inline a function as a callback with custom parameters.

 You can use this macro to inline a function as a callback, allowing you to
 define the callback function right where the widget and callback are declared,
 similar to a Lambda function.

 The first argument of the macro specifies the widget that will handle the
 callback. Next, you can include up to five triplets, where each triplet
 consists of a type, a parameter name, and a value. For example, `int, x, 3`
 specifies an integer parameter with a value of 3. If you need to pass two
 arguments, you can use two triplets, such as `int, x, 3, int, y, 4`.
 The last argument is the actual function body itself.

 The function body is limited to a syntax that the macro preprocessor can
 handle. It should include the leading '{' and trailing '}' and may contain
 local variable declarations, use global variables and functions, and use also
 the variables listed and initialized in the argument triples of the macro.
 Very large function bodies should be avoided because they may exceed the
 admissible size of a macro argument.

 Whenever the code generated by the macro is called, the custom parameters are
 duplicated and marked for automatic deallocation using `delete` when the
 callback widget is destroyed.

 \code{.cpp}
 #include <FL/fl_callback_macros.H>
 ...
 Fl_Button *btn = new Fl_Button(10, 10, 100, 20, "Test");
 FL_INLINE_CALLBACK(btn,
   Fl_String, name, btn->label(),
   {
     fl_message("Greetings from the %s button", name);
   }
 );
 \endcode

 You can find a small demonstration program showcasing the usage of
 `FL_*_CALLBACK` in the `examples/callbacks.cxx` file.

 \param WIDGET the widget that will call the callback
 \param FUNC the function body within the limits of the C macro preprocessor
 \param ... a list of zero to five triplets, each declaring a type, name, and value

 \see FL_METHOD_CALLBACK, FL_FUNCTION_CALLBACK
 */
#define FL_INLINE_CALLBACK(WIDGET, ...)

#else // FL_DOXYGEN

/*
 All macros start with _FL_CBD_ to avoid naming conflicts.

 For MACRO(int, a, 1, int, b, 2):
 
 _FL_CBD_LIST_MEMBERS_2  generates `int a_; int b_;`
 _FL_CBD_LIST_FN_ARGS_2  generates `int a, int b`
 _FL_CBD_LIST_ARGS_2     generates `cbdata->a_, cbdata->b_`
 _FL_CBD_LIST_VALUES_2   generates `1, 2`
 _FL_CBD_LIST_INIT_2     generates `: a_(a), b_(b)`
*/
#define _FL_CBD_LIST_MEMBERS_5(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, i40, i41, i42, ...) i00 i01##_; i10 i11##_; i20 i21##_; i30 i31##_; i40 i41##_;
#define _FL_CBD_LIST_FN_ARGS_5(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, i40, i41, i42, ...) i00 i01, i10 i11, i20 i21, i30 i31, i40 i41
#define _FL_CBD_LIST_ARGS_5(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, i40, i41, i42, ...) cbdata->i01##_, cbdata->i11##_, cbdata->i21##_, cbdata->i31##_, cbdata->i41##_
#define _FL_CBD_LIST_VALUES_5(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, i40, i41, i42, ...) i02, i12, i22, i32, i42
#define _FL_CBD_LIST_INIT_5(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, i40, i41, i42, ...) : i01##_(i01), i11##_(i11), i21##_(i21), i31##_(i31), i41##_(i41)
#define _FL_CBD_LIST_LAMBDA_5(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, i40, i41, i42, LAMBDA) LAMBDA

#define _FL_CBD_LIST_MEMBERS_4(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, ...) i00 i01##_; i10 i11##_; i20 i21##_; i30 i31##_;
#define _FL_CBD_LIST_FN_ARGS_4(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, ...) i00 i01, i10 i11, i20 i21, i30 i31
#define _FL_CBD_LIST_ARGS_4(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, ...) cbdata->i01##_, cbdata->i11##_, cbdata->i21##_, cbdata->i31##_
#define _FL_CBD_LIST_VALUES_4(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, ...) i02, i12, i22, i32
#define _FL_CBD_LIST_INIT_4(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, ...) : i01##_(i01), i11##_(i11), i21##_(i21), i31##_(i31)
#define _FL_CBD_LIST_LAMBDA_4(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, LAMBDA) LAMBDA

#define _FL_CBD_LIST_MEMBERS_3(i00, i01, i02, i10, i11, i12, i20, i21, i22, ...) i00 i01##_; i10 i11##_; i20 i21##_;
#define _FL_CBD_LIST_FN_ARGS_3(i00, i01, i02, i10, i11, i12, i20, i21, i22, ...) i00 i01, i10 i11, i20 i21
#define _FL_CBD_LIST_ARGS_3(i00, i01, i02, i10, i11, i12, i20, i21, i22, ...) cbdata->i01##_, cbdata->i11##_, cbdata->i21##_
#define _FL_CBD_LIST_VALUES_3(i00, i01, i02, i10, i11, i12, i20, i21, i22, ...) i02, i12, i22
#define _FL_CBD_LIST_INIT_3(i00, i01, i02, i10, i11, i12, i20, i21, i22, ...) : i01##_(i01), i11##_(i11), i21##_(i21)
#define _FL_CBD_LIST_LAMBDA_3(i00, i01, i02, i10, i11, i12, i20, i21, i22, LAMBDA) LAMBDA

#define _FL_CBD_LIST_MEMBERS_2(i00, i01, i02, i10, i11, i12, ...) i00 i01##_; i10 i11##_;
#define _FL_CBD_LIST_FN_ARGS_2(i00, i01, i02, i10, i11, i12, ...) i00 i01, i10 i11
#define _FL_CBD_LIST_ARGS_2(i00, i01, i02, i10, i11, i12, ...) cbdata->i01##_, cbdata->i11##_
#define _FL_CBD_LIST_VALUES_2(i00, i01, i02, i10, i11, i12, ...) i02, i12
#define _FL_CBD_LIST_INIT_2(i00, i01, i02, i10, i11, i12, ...) : i01##_(i01), i11##_(i11)
#define _FL_CBD_LIST_LAMBDA_2(i00, i01, i02, i10, i11, i12, LAMBDA) LAMBDA

#define _FL_CBD_LIST_MEMBERS_1(i00, i01, i02, ...) i00 i01##_;
#define _FL_CBD_LIST_FN_ARGS_1(i00, i01, i02, ...) i00 i01
#define _FL_CBD_LIST_ARGS_1(i00, i01, i02, ...) cbdata->i01##_
#define _FL_CBD_LIST_VALUES_1(i00, i01, i02, ...) i02
#define _FL_CBD_LIST_INIT_1(i00, i01, i02, ...) : i01##_(i01)
#define _FL_CBD_LIST_LAMBDA_1(i00, i01, i02, LAMBDA) LAMBDA

#define _FL_CBD_LIST_MEMBERS_0(...)
#define _FL_CBD_LIST_FN_ARGS_0(...)
#define _FL_CBD_LIST_ARGS_0(...)
#define _FL_CBD_LIST_VALUES_0(...)
#define _FL_CBD_LIST_INIT_0(...)
#define _FL_CBD_LIST_LAMBDA_0(LAMBDA) LAMBDA

/*
 This macro generates an integer between 0 and 5, depending on the number
 of arguments given, divided by thre. A typical call is
 `_FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0)`
 */
#define _FL_CBD_COUNT_BY_3(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, i40, i41, i42, cnt, ...) cnt
#define _FL_CBD_COUNT_BY_3_L(i00, i01, i02, i10, i11, i12, i20, i21, i22, i30, i31, i32, i40, i41, i42, lambda, cnt, ...) cnt

/*
 These two macros make it possible to call macros with names that are created
 by concatenating the name in x and (in this context) the number in y.
 */
#define _FL_CBD_CONCAT_IMPL(x, y) x##y
#define _FL_CBD_CONCAT(x, y) _FL_CBD_CONCAT_IMPL(x, y)

/*
 Create a unique name for the derived class based on the current source code
 line number.
 */
#define _FL_CBD_CLASS_NAME _FL_CBD_CONCAT(Fl_Callback_User_Data_,__LINE__)

/*
  This macro creates boilerplate code for callbacks to functions and
  static class methods with up to five arguments.

  This macro invocation for example
  ```
  FL_FUNCTION_CALLBACK( func_cb_btn_2, hello_2_args_cb,
                        const char *, text, "FLTK",
                        int, number, 2);
  ```
  will generate the following code:

  ```
  do {
    class Fl_Callback_User_Data_92 : public Fl_Callback_User_Data {
      public:
        const char * text_;
        int number_;
        static void cb(Fl_Widget *w, void *user_data) {
          Fl_Callback_User_Data_92 *cbdata = (Fl_Callback_User_Data_92*)user_data;
          hello_2_args_cb(cbdata->text_, cbdata->number_);
        };
        Fl_Callback_User_Data_92(const char * text, int number)
        : text_(text),
          number_(number)
        { }
    };
    func_cb_btn_2->callback(Fl_Callback_User_Data_92::cb,
                            new Fl_Callback_User_Data_92("FLTK", 2),
                            true);
  } while(0)
  ```

  Clicking the Fl_Button `func_cb_btn_2` will call `hello_2_args_cb("FLTK", 2)`.
  Deleting the button will also delete the data that was created in our
  boilerplate code.
 */
#define FL_FUNCTION_CALLBACK(WIDGET, FUNC, ...) \
  do {  /* the do...while(0) pattern allows for a trailing semicolon, making the macro look more like a function call */ \
    class _FL_CBD_CLASS_NAME : public Fl_Callback_User_Data { /* create a local class with a unique name for one-time use */ \
    public: \
      /* generate a list of all callback argument, making them members of this class */ \
      _FL_CBD_CONCAT(_FL_CBD_LIST_MEMBERS_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__) \
      /* generate code for a static method used as a callback */ \
      static void cb(Fl_Widget *w, void *user_data) { \
        /* cast user_data into a poinbter to our local class type */ \
        _FL_CBD_CLASS_NAME *cbdata = (_FL_CBD_CLASS_NAME*)user_data; \
        (void)cbdata; /* supress unused variable warning */ \
        /* call a function or static method with up to 5 arguments */ \
        FUNC(_FL_CBD_CONCAT(_FL_CBD_LIST_ARGS_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__)); \
      }; \
      /* generate the class constructor */ \
      _FL_CBD_CLASS_NAME(_FL_CBD_CONCAT(_FL_CBD_LIST_FN_ARGS_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__)) \
        /* generate the initialiser list */ \
        _FL_CBD_CONCAT(_FL_CBD_LIST_INIT_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__) { } \
    }; \
    /* set the widget callback to call our local method with a new instance of our class */ \
    WIDGET->callback(_FL_CBD_CLASS_NAME::cb, new _FL_CBD_CLASS_NAME(_FL_CBD_CONCAT(_FL_CBD_LIST_VALUES_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__)), true); \
  } while(0)

/*
  This macro creates boilerplate code for callbacks to class methods
  with up to five arguments.

  This macro invocation for example
  ```
  FL_METHOD_CALLBACK(btn,
                     MyWindow, win, resize,
                     int, x, test_x+10,
                     int, y, test_y+10,
                     int, w, 320,
                     int, w, 400);
  ```
  will generate the following code:

  ```
  do {
    class Fl_Callback_User_Data_73 : public Fl_Callback_User_Data {
    public:
      int x_;
      int y_;
      int w_;
      int h_;
      MyWindow *win_;
      static void cb(Fl_Widget *w, void *user_data) {
        Fl_Callback_User_Data_73 *cbdata = (Fl_Callback_User_Data_73*)user_data;
        cbdata->win_->resize(cbdata->x_, cbdata->y_, cbdata->w_, cbdata->h_);
      };
      Fl_Callback_User_Data_73(int x, int y, int w, int h, MyWindow *win)
      : a_(a), b_(b), c_(c), win_(win) { }
    };
    btn->callback(Fl_Callback_User_Data_73::cb,
                  new Fl_Callback_User_Data_73(test_x+10, test_y+10, 320, 400, win),
                  true);
  } while(0);
  ```

  Clicking the Fl_Button `btn` will call
  `win->resize(test_x+10, test_y+10, 320, 400);`.
  Deleting the button will also delete the data that was created in our
  boilerplate code.
 */
#define FL_METHOD_CALLBACK(WIDGET, CLASS, SELF, METH, ...) \
  do {  /* the do...while(0) pattern allows for a trailing semicolon, making the macro look more like a function call */ \
    class _FL_CBD_CLASS_NAME : public Fl_Callback_User_Data { /* create a local class with a unique name for one-time use */ \
    public: \
      /* generate a list of all callback argument, making them members of this class */ \
      _FL_CBD_CONCAT(_FL_CBD_LIST_MEMBERS_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__) \
      /* store a pointer to the target class instance */ \
      CLASS *SELF##_; \
      /* generate code for a static method used as a callback */ \
      static void cb(Fl_Widget *w, void *user_data) { \
        /* cast user_data into a poinbter to our local class type */ \
        _FL_CBD_CLASS_NAME *cbdata = (_FL_CBD_CLASS_NAME*)user_data; \
        (void)cbdata; /* supress unused variable warning */ \
        /* call a class method with up to 5 arguments */ \
        cbdata->SELF##_->METH(_FL_CBD_CONCAT(_FL_CBD_LIST_ARGS_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__)); \
      }; \
      /* generate the class constructor */ \
      _FL_CBD_CLASS_NAME(_FL_CBD_CONCAT(_FL_CBD_LIST_FN_ARGS_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__), CLASS *SELF) \
        /* generate the initialiser list */ \
        _FL_CBD_CONCAT(_FL_CBD_LIST_INIT_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__), SELF##_(SELF) { } \
    }; \
    /* set the widget callback to call our local method with a new instance of our class */ \
    WIDGET->callback(_FL_CBD_CLASS_NAME::cb, new _FL_CBD_CLASS_NAME(_FL_CBD_CONCAT(_FL_CBD_LIST_VALUES_, _FL_CBD_COUNT_BY_3(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__), SELF), true); \
  } while(0)

/*
  This macro creates boilerplate code for callback functions inlined into
  the widget creation code (similar to lambda functions in C++11 and up)
  with up to five arguments.

  This macro invocation for example
  ```
  FL_INLINE_CALLBACK(btn,
    const char *, text, "FLTK", int, number, 2,
      {
        fl_message("We received the message %s with %d!", text, number);
      }
    );
  ```
  will generate the following code:

  ```
  do {
    class Fl_Callback_User_Data_133 : public Fl_Callback_User_Data {
    public:
      const char * text_;
      int number_;
      static void fn(const char * text, int number ) {
        fl_message("We received the message %s with %d!", text, number);
      };
      static void cb(Fl_Widget *w, void *user_data) {
        Fl_Callback_User_Data_133 *cbdata = (Fl_Callback_User_Data_133*)user_data;
        fn(cbdata->text_, cbdata->number_);
      };
      Fl_Callback_User_Data_133(const char * text, int number)
      : text_(text),
        number_(number) { }
    };
    btn(Fl_Callback_User_Data_133::cb,
        new Fl_Callback_User_Data_133("FLTK", 2),
        true);
  } while(0);
  ```

  Clicking the Fl_Button `btn` will call
 `fl_message("We received the message %s with %d!", "FLTK", 2);`.
  Deleting the button will also delete the data that was created in our
  boilerplate code.
 */
#define FL_INLINE_CALLBACK(WIDGET, ...) \
  do {  /* the do...while(0) pattern allows for a trailing semicolon, making the macro look more like a function call */ \
    class _FL_CBD_CLASS_NAME : public Fl_Callback_User_Data { /* create a local class with a unique name for one-time use */ \
    public: \
      /* generate a list of all callback argument, making them members of this class */ \
      _FL_CBD_CONCAT(_FL_CBD_LIST_MEMBERS_, _FL_CBD_COUNT_BY_3_L(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__) \
      /* generate the actual inline function */ \
      static void fn(\
        _FL_CBD_CONCAT(_FL_CBD_LIST_FN_ARGS_, _FL_CBD_COUNT_BY_3_L(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__) \
      ) _FL_CBD_CONCAT(_FL_CBD_LIST_LAMBDA_, _FL_CBD_COUNT_BY_3_L(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__); \
      /* generate code for a static method used as a callback */ \
      static void cb(Fl_Widget *w, void *user_data) { \
        /* cast user_data into a poinbter to our local class type */ \
        _FL_CBD_CLASS_NAME *cbdata = (_FL_CBD_CLASS_NAME*)user_data; \
        (void)cbdata; /* supress unused variable warning */ \
        /* call inlined with up to 5 arguments */ \
        fn(_FL_CBD_CONCAT(_FL_CBD_LIST_ARGS_, _FL_CBD_COUNT_BY_3_L(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__)); \
      }; \
      /* generate the class constructor */ \
      _FL_CBD_CLASS_NAME(_FL_CBD_CONCAT(_FL_CBD_LIST_FN_ARGS_, _FL_CBD_COUNT_BY_3_L(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__)) \
        /* generate the initialiser list */ \
        _FL_CBD_CONCAT(_FL_CBD_LIST_INIT_, _FL_CBD_COUNT_BY_3_L(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__) { } \
    }; \
    /* set the widget callback to call our local method with a new instance of our class */ \
    WIDGET->callback(_FL_CBD_CLASS_NAME::cb, new _FL_CBD_CLASS_NAME(_FL_CBD_CONCAT(_FL_CBD_LIST_VALUES_, _FL_CBD_COUNT_BY_3_L(__VA_ARGS__, 5, err, err, 4, err, err, 3, err, err, 2, err, err, 1, err, 0, 0))(__VA_ARGS__)), true); \
  } while(0)

#endif // FL_DOXYGEN

#endif /* !_FL_FL_CALLBACK_MACROS_H_ */
