# data file for the Fltk User Interface Designer (fluid)
version 1.0401
header_name {.h}
code_name {.cxx}
comment {//
// Code dialogs for the Fast Light Tool Kit (FLTK).
//
// Copyright 1998-2023 by Bill Spitzak and others.
//
// This library is free software. Distribution and use rights are outlined in
// the file "COPYING" which should have been included with this file.  If this
// file is missing or damaged, see the license at:
//
//     https://www.fltk.org/COPYING.php
//
// Please see the following page on how to report bugs and issues:
//
//     https://www.fltk.org/bugs.php
//
} {in_source in_header
}

decl {\#include "fluid.h"} {private local
}

decl {\#include "file.h"} {private local
}

decl {\#include "../src/flstring.h"} {selected private local
}

decl {\#include <FL/Fl_Tabs.H>} {private local
}

decl {\#include <FL/Fl_Button.H>} {private local
}

decl {char *cv_source_filename = NULL;} {private local
}

decl {char *cv_header_filename = NULL;} {private local
}

decl {char *cv_design_filename = NULL;} {private local
}

decl {int cv_code_choice;} {public local
}

decl {extern void select_only(Fl_Type *o);} {private global
}

decl {extern void reveal_in_browser(Fl_Type *t);} {private global
}

Function {update_codeview_position()} {
  comment {Update the header and source code highlighting depending on the
currently selected object

The Code View system offers an immediate preview of the code
files that will be generated by FLUID. It also marks the code
generated for the last selected item in the header and the source
file.} open return_type void
} {
  code {if (!codeview_panel || !codeview_panel->visible())
    return;
  if (cv_autoposition->value()==0)
    return;
  if (codeview_panel && codeview_panel->visible() && Fl_Type::current) {
    int pos0 = 0, pos1 = 0;
    if (cv_source->visible_r()) {
      switch (cv_code_choice) {
        case 0: // prolog: not yet (include statements)
          pos0 = Fl_Type::current->code1_start;
          pos1 = Fl_Type::current->code2_end;
          break;
        case 1: // static: callbacks, menu declarations
          pos0 = Fl_Type::current->code_static_start;
          pos1 = Fl_Type::current->code_static_end;
          break;
        case 2: // code: entire implementation block including children
          pos0 = Fl_Type::current->code1_start;
          pos1 = Fl_Type::current->code2_end;
          break;
        case 3: // code1: all implementation code before the children
          pos0 = Fl_Type::current->code1_start;
          pos1 = Fl_Type::current->code1_end;
          break;
        case 4: // code1: all implementation code before the children
          pos0 = Fl_Type::current->code2_start;
          pos1 = Fl_Type::current->code2_end;
          break;
      }
      if (pos0>=0) {
        if (pos1<pos0)
          pos1 = cv_source->buffer()->line_end(pos0);
        cv_source->buffer()->highlight(pos0, pos1);
        int line = cv_source->buffer()->count_lines(0, pos0);
        cv_source->scroll(line, 0);
      }
    }
    if (cv_header->visible_r()) {
      switch (cv_code_choice) {
        case 0: // prolog: not yet (include statements)
        case 1: // static: callbacks, menu declarations
          pos0 = Fl_Type::current->header_static_start;
          pos1 = Fl_Type::current->header_static_end;
          break;
        case 2: // code: entire implementation block including children
          pos0 = Fl_Type::current->header1_start;
          pos1 = Fl_Type::current->header2_end;
          break;
        case 3: // code1: all implementation code before the children
          pos0 = Fl_Type::current->header1_start;
          pos1 = Fl_Type::current->header1_end;
          break;
        case 4: // code1: all implementation code before the children
          pos0 = Fl_Type::current->header2_start;
          pos1 = Fl_Type::current->header2_end;
          break;
      }
      if (pos0>=0) {
        if (pos1<pos0)
          pos1 = cv_header->buffer()->line_end(pos0);
        cv_header->buffer()->highlight(pos0, pos1);
        int line = cv_header->buffer()->count_lines(0, pos0);
        cv_header->scroll(line, 0);
      }
    }
    if (cv_project->visible_r()) {
      switch (cv_code_choice) {
        case 0: // prolog: not yet (include statements)
        case 1: // static: callbacks, menu declarations
        case 2: // code: entire implementation block including children
          pos0 = Fl_Type::current->proj1_start;
          pos1 = Fl_Type::current->proj2_end;
          break;
        case 3: // code1: all implementation code before the children
          pos0 = Fl_Type::current->proj1_start;
          pos1 = Fl_Type::current->proj1_end;
          break;
        case 4: // code1: all implementation code before the children
          pos0 = Fl_Type::current->proj2_start;
          pos1 = Fl_Type::current->proj2_end;
          break;
      }
      if (pos0>=0) {
        if (pos1<pos0)
          pos1 = cv_project->buffer()->line_end(pos0);
        cv_project->buffer()->highlight(pos0, pos1);
        int line = cv_project->buffer()->count_lines(0, pos0);
        cv_project->scroll(line, 0);
      }
    }
  }} {}
}

Function {update_codeview_position_cb(class Fl_Tabs*, void*)} {
  comment {Callback to update the codeview position.} open return_type void
} {
  code {// make sure that the selected tab shows the current view
  update_codeview_cb(0,0);
  // highlight the selected widget in the selected tab
  update_codeview_position();} {}
}

Function {update_codeview_cb(class Fl_Button*, void*)} {
  comment {Generate a header, source, strings, or design file in a temporary directory
and load those into the Code Viewer widgets.} open return_type void
} {
  code {if (!codeview_panel || !codeview_panel->visible())
    return;

  if (!cv_source_filename) {
    cv_source_filename = (char*)malloc(FL_PATH_MAX);
    fl_strlcpy(cv_source_filename, get_tmpdir().c_str(), FL_PATH_MAX);
    fl_strlcat(cv_source_filename, "codeview_tmp.cxx", FL_PATH_MAX);
  }
  if (!cv_header_filename) {
    cv_header_filename = (char*)malloc(FL_PATH_MAX);
    fl_strlcpy(cv_header_filename, get_tmpdir().c_str(), FL_PATH_MAX);
    fl_strlcat(cv_header_filename, "codeview_tmp.h", FL_PATH_MAX);
  }
  if (!cv_design_filename) {
    cv_design_filename = (char*)malloc(FL_PATH_MAX);
    fl_strlcpy(cv_design_filename, get_tmpdir().c_str(), FL_PATH_MAX);
    fl_strlcat(cv_design_filename, "codeview_tmp.fl", FL_PATH_MAX);
  }

  if (cv_project->visible_r()) {
    write_file(cv_design_filename, false, true);
    int top = cv_project->top_line();
    cv_project->buffer()->loadfile(cv_design_filename);
    cv_project->scroll(top, 0);
  } else if (cv_strings->visible_r()) {
    static const char *exts[] = { ".txt", ".po", ".msg" };
    char fn[FL_PATH_MAX+1];
    fl_strlcpy(fn, get_tmpdir().c_str(), FL_PATH_MAX);
    fl_strlcat(fn, "strings", FL_PATH_MAX);
    fl_filename_setext(fn, FL_PATH_MAX, exts[g_project.i18n_type]);
    write_strings(fn);
    int top = cv_strings->top_line();
    cv_strings->buffer()->loadfile(fn);
    cv_strings->scroll(top, 0);
  } else if (cv_source->visible_r() || cv_header->visible_r()) {
    Fl_String code_file_name_bak = g_project.code_file_name;
    g_project.code_file_name = cv_source_filename;
    Fl_String header_file_name_bak = g_project.header_file_name;
    g_project.header_file_name = cv_header_filename;

    // generate the code and load the files
    Fd_Code_Writer f;
    // generate files
    if (f.write_code(cv_source_filename, cv_header_filename, true))
    {
      // load file into source editor
      int pos = cv_source->top_line();
      cv_source->buffer()->loadfile(cv_source_filename);
      cv_source->scroll(pos, 0);
      // load file into header editor
      pos = cv_header->top_line();
      cv_header->buffer()->loadfile(cv_header_filename);
      cv_header->scroll(pos, 0);
      // update the source code highlighting
      update_codeview_position();
    }

    g_project.code_file_name = code_file_name_bak;
    g_project.header_file_name = header_file_name_bak;
  }} {}
}

Function {update_codeview_timer(void*)} {
  comment {This is called by the timer itself
} open return_type void
} {
  code {update_codeview_cb(0,0);} {}
}

Function {codeview_defer_update()} {open return_type void
} {
  code {// we will only update earliest 0.5 seconds after the last change, and only
    // if no other change was made, so dragging a widget will not generate any
    // CPU load
    Fl::remove_timeout(update_codeview_timer, 0);
    Fl::add_timeout(0.5, update_codeview_timer, 0);} {}
}

Function {codeview_toggle_visibility()} {
  comment {Show or hide the source code preview.
The state is stored in the app preferences.
} open return_type void
} {
  code {if (!codeview_panel) {
    make_codeview();
    codeview_panel->callback((Fl_Callback*)toggle_codeview_cb);
    Fl_Preferences svp(fluid_prefs, "codeview");
    int autorefresh;
    svp.get("autorefresh", autorefresh, 1);
    cv_autorefresh->value(autorefresh);
    int autoposition;
    svp.get("autoposition", autoposition, 1);
    cv_autoposition->value(autoposition);
    int tab;
    svp.get("tab", tab, 0);
    if (tab>=0 && tab<cv_tab->children()) cv_tab->value(cv_tab->child(tab));
    svp.get("code_choice", cv_code_choice, 2);
    cv_code_choice_w->value(cv_code_choice_w->find_item_with_argument(cv_code_choice));
    if (!position_window(codeview_panel,"codeview_pos", 0, 320, 120, 550, 500)) return;
  }

  if (codeview_panel->visible()) {
    codeview_panel->hide();
    codeview_item->label("Show Code View");
  } else {
    codeview_panel->show();
    codeview_item->label("Hide Code View");
    update_codeview_cb(0,0);
  }} {}
}

Function {make_codeview()} {open
} {
  Fl_Window codeview_panel {
    label {Code View}
    callback toggle_codeview_cb open
    xywh {389 507 520 515} type Double align 80 resizable size_range {384 120 0 0} visible
  } {
    Fl_Tabs cv_tab {
      callback update_codeview_position_cb open
      xywh {10 10 500 440} selection_color 4 labelcolor 7 resizable
    } {
      Fl_Group cv_source_tab {
        label Source open
        xywh {10 35 500 415} labelsize 13 resizable
      } {
        Fl_Text_Editor cv_source {
          xywh {10 40 500 410} textfont 4 textsize 11 resizable
          code0 {\#include "CodeEditor.h"}
          code1 {o->linenumber_width(60);}
          code2 {o->linenumber_size(o->Fl_Text_Display::textsize());}
          class CodeViewer
        }
      }
      Fl_Group {} {
        label Header open
        xywh {10 35 500 415} labelsize 13 hide
      } {
        Fl_Text_Editor cv_header {
          xywh {10 40 500 410} textfont 4 textsize 11 resizable
          code0 {\#include "CodeEditor.h"}
          code1 {o->linenumber_width(60);}
          code2 {o->linenumber_size(o->Fl_Text_Display::textsize());}
          class CodeViewer
        }
      }
      Fl_Group {} {
        label Strings open
        xywh {10 35 500 415} labelsize 13 hide
      } {
        Fl_Text_Display cv_strings {
          xywh {10 40 500 410} textfont 4 textsize 11 resizable
          code1 {o->linenumber_width(60);}
          code2 {o->linenumber_size(o->Fl_Text_Display::textsize());}
          class TextViewer
        }
      }
      Fl_Group {} {
        label Project open
        xywh {10 35 500 415} labelsize 13 hide
      } {
        Fl_Text_Display cv_project {
          xywh {10 40 500 410} textfont 4 textsize 11 resizable
          code1 {o->linenumber_width(60);}
          code2 {o->linenumber_size(o->Fl_Text_Display::textsize());}
          class TextViewer
        }
      }
    }
    Fl_Group cv_find_row {open
      xywh {10 460 500 20}
    } {
      Fl_Button cv_find_text_case {
        label aA
        xywh {244 460 25 20} type Toggle labelsize 11
      }
      Fl_Input cv_find_text {
        label {Find:}
        callback {Fl_Text_Display *e = NULL;
if (cv_source->visible_r()) {
  e = cv_source;
} else if (cv_header->visible_r()) {
  e = cv_header;
} else if (cv_project->visible_r()) {
  e = cv_project;
}
if (e) {
  Fl_Text_Buffer *b = e->buffer();
  int pos = e->insert_position();
  int found = b->search_forward(pos, o->value(), &pos, cv_find_text_case->value());
  if (found) {
    b->select(pos, pos + (int)strlen(o->value()));
    e->insert_position(pos);
    e->show_insert_position();
  }
}}
        xywh {40 460 200 20} labelsize 11 when 15 textsize 11
      }
      Fl_Button {} {
        label {<<}
        callback {Fl_Text_Display *e = NULL;
if (cv_source->visible_r()) {
  e = cv_source;
} else if (cv_header->visible_r()) {
  e = cv_header;
} else if (cv_project->visible_r()) {
  e = cv_project;
}
if (e) {
  const char *needle = cv_find_text->value();
  Fl_Text_Buffer *b = e->buffer();
  int pos = e->insert_position()-1;
  if (pos < 0) pos = b->length()-1;
  int found = b->search_backward(pos, needle, &pos, cv_find_text_case->value());
  if (!found)
    found = b->search_backward(b->length()-1, needle, &pos, cv_find_text_case->value());
  if (found) {
    b->select(pos, pos + (int)strlen(needle));
    e->insert_position(pos);
    e->show_insert_position();
  }
}}
        xywh {273 460 25 20} labelsize 11
      }
      Fl_Button {} {
        label {>>}
        callback {Fl_Text_Display *e = NULL;
if (cv_source->visible_r()) {
  e = cv_source;
} else if (cv_header->visible_r()) {
  e = cv_header;
} else if (cv_project->visible_r()) {
  e = cv_project;
}
if (e) {
  const char *needle = cv_find_text->value();
  Fl_Text_Buffer *b = e->buffer();
  int pos = e->insert_position() + 1;
  if (pos+1 >= b->length()) pos = 0;
  int found = b->search_forward(pos, needle, &pos, cv_find_text_case->value());
  if (!found && (pos > 0))
    found = b->search_forward(0, needle, &pos, cv_find_text_case->value());
  if (found) {
    b->select(pos, pos + (int)strlen(needle));
    e->insert_position(pos);
    e->show_insert_position();
  }
}}
        xywh {298 460 25 20} labelsize 11
      }
      Fl_Button {} {
        label Reveal
        callback {if (codeview_panel && codeview_panel->visible()) {
  Fl_Type *node = NULL;
  if (cv_source->visible_r())
    node = Fl_Type::find_in_text(0, cv_source->insert_position());
  else if (cv_header->visible_r())
    node = Fl_Type::find_in_text(1, cv_header->insert_position());
  else if (cv_project->visible_r())
    node = Fl_Type::find_in_text(2, cv_project->insert_position());
  if (node) {
    select_only(node);
    reveal_in_browser(node);
    if (Fl::event_clicks()==1) // double click
      node->open();
  }
}}
        xywh {327 460 61 20} labelsize 11
      }
      Fl_Box {} {
        xywh {490 460 20 20} resizable
      }
    }
    Fl_Group cv_settings_row {open
      xywh {10 485 500 20}
    } {
      Fl_Button {} {
        label Refresh
        callback update_codeview_cb
        xywh {10 485 61 20} labelsize 11
      }
      Fl_Light_Button cv_autorefresh {
        label {Auto-Refresh}
        xywh {77 485 91 20} labelsize 11
        code0 {o->callback((Fl_Callback*)update_codeview_cb);}
      }
      Fl_Light_Button cv_autoposition {
        label {Auto-Position}
        xywh {172 485 89 20} labelsize 11
      }
      Fl_Choice cv_code_choice_w {
        callback {cv_code_choice = (int)o->mvalue()->argument();
update_codeview_position();} open
        xywh {265 485 70 20} down_box BORDER_BOX labelsize 11 textsize 11
      } {
        MenuItem {} {
          label prolog
          user_data 0 user_data_type long
          tooltip {Include statements in header or source code} xywh {0 0 100 20} labelsize 11 hide
        }
        MenuItem {} {
          label static
          user_data 1 user_data_type long
          tooltip {static declarations in source code} xywh {10 10 100 20} labelsize 11
        }
        MenuItem {} {
          label code
          user_data 2 user_data_type long
          tooltip {widget code block including children} xywh {20 20 100 20} labelsize 11
        }
        MenuItem {} {
          label {code 1}
          user_data 3 user_data_type long
          tooltip {widget code block before children} xywh {30 30 100 20} labelsize 11
        }
        MenuItem {} {
          label {code 2}
          user_data 4 user_data_type long
          tooltip {widget code block after children} xywh {40 40 100 20} labelsize 11
        }
      }
      Fl_Box {} {
        xywh {375 485 80 20} resizable
      }
      Fl_Button {} {
        label Close
        callback toggle_codeview_b_cb
        xywh {460 485 50 20} labelsize 11
      }
    }
  }
}

comment {
//} {in_source in_header
}
