# data file for the Fltk User Interface Designer (fluid)
version 1.0500
header_name {.h}
code_name {.cxx}
snap {
  ver 1
  current_suite FLTK
  current_preset 1
}
comment {//
// Widget panel for the Fast Light Tool Kit (FLTK).
//
// Copyright 1998-2021 by Bill Spitzak and others.
//
// This library is free software. Distribution and use rights are outlined in
// the file "COPYING" which should have been included with this file.  If this
// file is missing or damaged, see the license at:
//
//     https://www.fltk.org/COPYING.php
//
// Please see the following page on how to report bugs and issues:
//
//     https://www.fltk.org/bugs.php
//
} {in_source in_header
}

decl {\#include "panels/widget_panel/Grid_Child_Tab.h"} {public global
}

decl {\#include "panels/widget_panel/Grid_Tab.h"} {public global
}

decl {\#include "widgets/Formula_Input.h"} {public global
}

decl {class Fl_Flex;} {public global
}

decl {\#include "Fluid.h"} {private global
}

decl {\#include "app/Snap_Action.h"} {private global
}

decl {\#include "app/Image_Asset.h"} {private global
}

decl {\#include "proj/undo.h"} {private global
}

decl {\#include "nodes/Window_Node.h"} {private global
}

decl {\#include "nodes/Grid_Node.h"} {private global
}

decl {\#include <FL/Fl_Spinner.H>} {private global
}

decl {\#include <FL/Fl_Grid.H>} {private global
}

decl {\#include <FL/Fl_Flex.H>} {private global
}

decl {\#include <FL/fl_ask.H>} {private global
}

decl {\#include <FL/Fl_Menu_Item.H>} {private global
}

decl {\#define ZERO_ENTRY 1000} {private global
}

decl {extern const char* when_symbol_name(int n);
extern void set_whenmenu(int n);
extern void redraw_browser();
const char *c_check(const char *c, int type=0);
extern Fl_Color fl_show_colormap(Fl_Color oldcol);
extern void labelcolor_common(Fl_Color c);
extern void color_common(Fl_Color c);
extern void color2_common(Fl_Color c);
extern void textcolor_common(Fl_Color c);
extern int widget_i;
extern fld::widget::Formula_Input_Vars widget_vars[];} {private global
}

decl {extern int numselected;
extern Fl_Menu_Item boxmenu[];} {private global
}

decl {extern int haderror;} {private global
}

Function {make_image_panel()} {
  comment {Create a panel for editing widget image data}
} {
  Fl_Window image_panel_window {
    label {Image Options}
    callback {propagate_load(o, v);} open
    xywh {527 684 260 332} type Double modal visible
  } {
    Fl_Group image_panel_imagegroup {
      callback propagate_load open
      xywh {10 15 235 125}
    } {
      Fl_Box {} {
        label { ---- Active Image ----}
        xywh {75 15 170 20} labelfont 1 labelsize 11 align 20
      }
      Fl_Box image_panel_data {
        label {... x ... pixels, ...}
        callback {if (v == LOAD) {
  Fl_Shared_Image *img = Fl_Shared_Image::get(widget_image_input->value());
  o->user_data(img);
  if (img) {
    char buf[256];
    snprintf(buf, 255, "%d x %d pixels, %d channels", img->data_w(), img->data_h(), img->d());
    o->copy_label(buf);
    image_panel_imagegroup->activate();
  } else if (widget_image_input->value() && widget_image_input->value()[0]) {
    o->label("Can't load image");
    image_panel_imagegroup->activate();
  } else {
    o->label("... x ... pixels, ...");
    image_panel_imagegroup->deactivate();
  }
}}
        xywh {75 35 170 20} labelsize 11 align 20
        code0 {\#include <FL/Fl_Shared_Image.H>}
      }
      Fl_Group {} {
        callback propagate_load open
        xywh {75 75 170 20}
      } {
        Fl_Input image_panel_imagew {
          label {Width:}
          callback {if (v == LOAD) {
    if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
      o->value(current_widget->scale_image_w_);
    }
  } else {
    int mod = 0;
    for (Node *t = Fluid.proj.tree.first; t; t = t->next) {
      if (t->selected && t->is_widget()) {
        Widget_Node* wt = ((Widget_Node*)t);
        wt->scale_image_w_ = o->value();
        Fl_Image *img = wt->o->image();
        if (img) {
          int iw = wt->scale_image_w_;
          if (iw<=0) iw = img->data_w();
          int ih = wt->scale_image_h_;
          if (ih<=0) ih = img->data_w();
          img->scale(iw, ih, 0, 1);
          wt->o->redraw();
          if (wt->o->parent()) wt->o->parent()->redraw();
        }
        mod = 1;
      }
    }
    if (mod) Fluid.proj.set_modflag(1);
  }}
          tooltip {Scale image to this width in pixel units} xywh {75 75 55 20} labelsize 11 align 5 textsize 11
          class {fld::widget::Formula_Input}
        }
        Fl_Input image_panel_imageh {
          label {Height:}
          callback {if (v == LOAD) {
    if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
      o->value(current_widget->scale_image_h_);
    }
  } else {
    int mod = 0;
    for (Node *t = Fluid.proj.tree.first; t; t = t->next) {
      if (t->selected && t->is_widget()) {
        Widget_Node* wt = ((Widget_Node*)t);
        wt->scale_image_h_ = o->value();
        Fl_Image *img = wt->o->image();
        if (img) {
          int iw = wt->scale_image_w_;
          if (iw<=0) iw = img->data_w();
          int ih = wt->scale_image_h_;
          if (ih<=0) ih = img->data_w();
          img->scale(iw, ih, 0, 1);
          wt->o->redraw();
          if (wt->o->parent()) wt->o->parent()->redraw();
        }
        mod = 1;
      }
    }
    if (mod) Fluid.proj.set_modflag(1);
  }}
          tooltip {Scale image to this height in pixel units} xywh {135 75 55 20} labelsize 11 align 5 textsize 11
          class {fld::widget::Formula_Input}
        }
        Fl_Button {} {
          label Reset
          callback {if (v != LOAD) {
  image_panel_imagew->value(0);
  image_panel_imageh->value(0);
  image_panel_imagew->do_callback();
  image_panel_imageh->do_callback();
}}
          tooltip {Reset scale to original size} xywh {195 75 50 20} labelsize 11
        }
      }
      Fl_Box {} {
        label {Scale:}
        xywh {10 75 60 20} labelfont 1 labelsize 11 align 24
      }
      Fl_Box {} {
        label {Storage:}
        xywh {10 100 60 20} labelfont 1 labelsize 11 align 24
      }
      Fl_Check_Button {} {
        label {convert to raw pixel data}
        callback {if (v == LOAD) {
  if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
    o->activate();
    o->value(!current_widget->compress_image_);
  } else {
    o->deactivate();
  }
} else {
  int mod = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->compress_image_ = !o->value();
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
        tooltip {if unchecked, keep the image in its original format and store the data as is; if checked, convert the image and store it as uncompressed RGB or grayscale pixel data} xywh {75 100 170 20} down_box DOWN_BOX labelsize 11
      }
      Fl_Check_Button {} {
        label {bind to widget}
        callback {if (v == LOAD) {
  if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
    o->activate();
    o->value(current_widget->bind_image_);
  } else {
    o->deactivate();
  }
} else {
  int mod = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->bind_image_ = o->value();
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
        tooltip {bind the image to the widget, so it will be deleted automatically} xywh {75 120 170 20} down_box DOWN_BOX labelsize 11 hotspot
      }
    }
    Fl_Group image_panel_deimagegroup {
      callback propagate_load open
      xywh {10 155 235 125}
    } {
      Fl_Box {} {
        label { ---- Inactive Image ----}
        xywh {75 155 170 20} labelfont 1 labelsize 11 align 20
      }
      Fl_Box image_panel_dedata {
        label {... x ... pixels, ...}
        callback {if (v == LOAD) {
  Fl_Shared_Image *img = Fl_Shared_Image::get(widget_deimage_input->value());
  o->user_data(img);
  if (img) {
    char buf[256];
    snprintf(buf, 255, "%d x %d pixels, %d channels", img->data_w(), img->data_h(), img->d());
    o->copy_label(buf);
    image_panel_deimagegroup->activate();
  } else if (widget_deimage_input->value() && widget_deimage_input->value()[0]) {
    o->label("Can't load image");
    image_panel_deimagegroup->activate();
  } else {
    o->label("... x ... pixels, ...");
    image_panel_deimagegroup->deactivate();
  }
}}
        xywh {75 175 170 20} labelsize 11 align 20
      }
      Fl_Group {} {
        callback propagate_load open
        xywh {75 215 170 20}
      } {
        Fl_Input image_panel_deimagew {
          label {Width:}
          callback {if (v == LOAD) {
    if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
      o->value(current_widget->scale_deimage_w_);
    }
  } else {
    int mod = 0;
    for (Node *t = Fluid.proj.tree.first; t; t = t->next) {
      if (t->selected && t->is_widget()) {
        Widget_Node* wt = ((Widget_Node*)t);
        wt->scale_deimage_w_ = o->value();
        Fl_Image *img = wt->o->deimage();
        if (img) {
          int iw = wt->scale_deimage_w_;
          if (iw<=0) iw = img->data_w();
          int ih = wt->scale_deimage_h_;
          if (ih<=0) ih = img->data_w();
          img->scale(iw, ih, 0, 1);
          wt->o->redraw();
          if (wt->o->parent()) wt->o->parent()->redraw();
        }
        mod = 1;
      }
    }
    if (mod) Fluid.proj.set_modflag(1);
  }}
          tooltip {Scale image to this width in pixel units} xywh {75 215 55 20} labelsize 11 align 5 textsize 11
          class {fld::widget::Formula_Input}
        }
        Fl_Input image_panel_deimageh {
          label {Height:}
          callback {if (v == LOAD) {
    if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
      o->value(current_widget->scale_deimage_h_);
    }
  } else {
    int mod = 0;
    for (Node *t = Fluid.proj.tree.first; t; t = t->next) {
      if (t->selected && t->is_widget()) {
        Widget_Node* wt = ((Widget_Node*)t);
        wt->scale_deimage_h_ = o->value();
        Fl_Image *img = wt->o->deimage();
        if (img) {
          int iw = wt->scale_deimage_w_;
          if (iw<=0) iw = img->data_w();
          int ih = wt->scale_deimage_h_;
          if (ih<=0) ih = img->data_w();
          img->scale(iw, ih, 0, 1);
          wt->o->redraw();
          if (wt->o->parent()) wt->o->parent()->redraw();
        }
        mod = 1;
      }
    }
    if (mod) Fluid.proj.set_modflag(1);
  }}
          tooltip {Scale image to this height in pixel units} xywh {135 215 55 20} labelsize 11 align 5 textsize 11
          class {fld::widget::Formula_Input}
        }
        Fl_Button {} {
          label Reset
          callback {if (v != LOAD) {
  image_panel_deimagew->value(0);
  image_panel_deimageh->value(0);
  image_panel_deimagew->do_callback();
  image_panel_deimageh->do_callback();
}}
          tooltip {Reset scale to original size} xywh {195 215 50 20} labelsize 11
        }
      }
      Fl_Box {} {
        label {Scale:}
        xywh {10 215 60 20} labelfont 1 labelsize 11 align 24
      }
      Fl_Box {} {
        label {Storage:}
        xywh {10 240 60 20} labelfont 1 labelsize 11 align 24
      }
      Fl_Check_Button {} {
        label {convert to raw pixel data}
        callback {if (v == LOAD) {
  if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
    o->activate();
    o->value(!current_widget->compress_deimage_);
  } else {
    o->deactivate();
  }
} else {
  int mod = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->compress_deimage_ = !o->value();
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
        tooltip {if unchecked, keep the image in its original format and store the data as is; if checked, convert the image and store it as uncompressed RGB or grayscale pixel data} xywh {75 240 170 20} down_box DOWN_BOX labelsize 11
      }
      Fl_Check_Button {} {
        label {bind to widget}
        callback {if (v == LOAD) {
  if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
    o->activate();
    o->value(current_widget->bind_deimage_);
  } else {
    o->deactivate();
  }
} else {
  int mod = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->bind_deimage_ = o->value();
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
        tooltip {bind the image to the widget, so it will be deleted automatically} xywh {75 260 170 20} down_box DOWN_BOX labelsize 11
      }
    }
    Fl_Button image_panel_close {
      label Close
      callback {if (v != LOAD)
  image_panel_window->hide();}
      xywh {165 295 80 20} labelsize 11
    }
  }
}

Function {run_image_panel()} {return_type void
} {
  code {if (!image_panel_window)
  make_image_panel();

image_panel_window->do_callback(image_panel_window, LOAD);

Fl::pushed(0);
Fl_Window *g = Fl::grab();
if (g) Fl::grab(0);
image_panel_window->show();
while (image_panel_window->shown())
  Fl::wait();
if (g)
  Fl::grab(g);

Fl_Shared_Image *img = (Fl_Shared_Image*)image_panel_data->user_data();
if (img) {
  img->release();
  image_panel_data->user_data(nullptr);
}} {}
}

Function {flex_margin_cb(Fl_Value_Input* i, void* v, void (*load_margin)(Fl_Flex*,Fl_Value_Input*), int (*update_margin)(Fl_Flex*,int))} {return_type void
} {
  code {if (v == LOAD) {
  if (current_widget->is_a(Type::Flex)) {
    load_margin((Fl_Flex*)current_widget->o, i);
  }
} else {
  int mod = 0;
  int new_value = (int)i->value();
  for (Node *o = Fluid.proj.tree.first; o; o = o->next) {
    if (o->selected && o->is_a(Type::Flex)) {
      Flex_Node* q = (Flex_Node*)o;
      Fl_Flex* w = (Fl_Flex*)q->o;
      if (update_margin(w, new_value)) {
        w->layout();
        mod = 1;
      }
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}} {}
}

Function {make_widget_panel()} {
  comment {Create a panel that can be used with all known widgets} open
} {
  Fl_Window {} {
    comment {Use a Double Window to avoid flickering.} open
    xywh {372 208 420 400} type Double labelsize 11 align 80 resizable hotspot
    code0 {o->size_range(o->w(), o->h());} size_range {420 400 0 0} visible
  } {
    Fl_Tabs widget_tabs {
      callback {propagate_load((Fl_Group *)o,v);} open
      xywh {10 10 400 350} selection_color 12 labelsize 11 labelcolor 7 when 0 resizable
      code0 {o->show();}
    } {
      Fl_Group wp_gui_tab {
        label GUI
        callback propagate_load open selected
        xywh {10 30 400 330} labelsize 11 when 0 resizable
      } {
        Fl_Group {} {
          label {Label:}
          callback propagate_load open
          xywh {95 40 309 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Input wp_gui_label {
            callback label_cb
            tooltip {The label text for the widget.
Use Ctrl-J for newlines.} xywh {95 40 190 20} labelfont 1 labelsize 11 when 15 textsize 11 resizable
          }
          Fl_Choice {} {
            callback labeltype_cb open
            tooltip {The label style for the widget.} xywh {285 40 119 20} box THIN_UP_BOX down_box BORDER_BOX labelfont 1 labelsize 11 textsize 11
            code0 {extern Fl_Menu_Item labeltypemenu[];}
            code1 {o->menu(labeltypemenu);}
          } {}
        }
        Fl_Group {} {
          label {Image:}
          callback propagate_load open
          xywh {95 65 309 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Input widget_image_input {
            callback {if (v == LOAD) {
  if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
    o->activate();
    o->value(((Widget_Node*)current_widget)->image_name());
  } else o->deactivate();
} else {
  int mod = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->image_name(o->value());
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The active image for the widget.} xywh {95 65 200 20} labelfont 1 labelsize 11 textsize 11 resizable
          }
          Fl_Button {} {
            label {Browse...}
            callback {if (v == LOAD) {
  if (current_widget->is_widget() && !current_widget->is_a(Type::Window))
    o->activate();
  else
    o->deactivate();
} else {
  int mod = 0;
  Image_Asset *image_asset = ui_find_image(widget_image_input->value());
  if (image_asset) {
    widget_image_input->value(image_asset->filename());
    for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
      q->image_name(image_asset->filename());
      mod = 1;
    }
    if (mod) Fluid.proj.set_modflag(1);
  }
}}
            tooltip {Click to choose the active image.} xywh {295 65 89 20} labelsize 11 align 256
          }
          Fl_Button {} {
            label {...}
            callback {if (v != LOAD) {
  run_image_panel();
}}
            tooltip {more image options} bind_image 1 xywh {384 65 20 20}
          }
        }
        Fl_Group {} {
          label {Inactive:}
          callback propagate_load open
          xywh {95 90 309 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Input widget_deimage_input {
            callback {if (v == LOAD) {
  if (current_widget->is_widget() && !current_widget->is_a(Type::Window)) {
    o->activate();
    o->value(((Widget_Node*)current_widget)->inactive_name());
  } else o->deactivate();
} else {
  int mod = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->inactive_name(o->value());
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The inactive image for the widget.} xywh {95 90 200 20} labelfont 1 labelsize 11 textsize 11 resizable
          }
          Fl_Button {} {
            label {Browse...}
            callback {if (v == LOAD) {
  if (current_widget->is_widget() && !current_widget->is_a(Type::Window))
    o->activate();
  else
    o->deactivate();
} else {
  int mod = 0;
  Image_Asset *image_asset = ui_find_image(widget_deimage_input->value());
  if (image_asset) {
    widget_deimage_input->value(image_asset->filename());
    for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
      q->inactive_name(image_asset->filename());
      mod = 1;
    }
    if (mod) Fluid.proj.set_modflag(1);
  }
}}
            tooltip {Click to choose the inactive image.} xywh {295 90 89 20} labelsize 11
          }
        }
        Fl_Group wp_gui_alignment {
          label {Alignment:}
          callback propagate_load open
          xywh {95 115 312 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Button {} {
            label Clip
            user_data {(fl_intptr_t)FL_ALIGN_CLIP}
            callback align_cb
            tooltip {Clip the label to the inside of the widget.} xywh {95 115 30 20} type Toggle selection_color 8 labelsize 11 align 16
          }
          Fl_Button {} {
            label Wrap
            user_data {(fl_intptr_t)FL_ALIGN_WRAP}
            callback align_cb
            tooltip {Wrap the label text.} xywh {130 115 38 20} type Toggle selection_color 8 labelsize 11
          }
          Fl_Button {} {
            label {@-1<-}
            user_data {(fl_intptr_t)FL_ALIGN_LEFT}
            callback align_cb
            tooltip {Left-align the label.} xywh {278 115 20 20} type Toggle selection_color 8 labelsize 11 labelcolor 8 hide
          }
          Fl_Button {} {
            label {@-1->}
            user_data {(fl_intptr_t)FL_ALIGN_RIGHT}
            callback align_cb
            tooltip {Right-align the label.} xywh {303 115 20 20} type Toggle selection_color 8 labelsize 11 labelcolor 8 hide
          }
          Fl_Button {} {
            label {@-18}
            user_data {(fl_intptr_t)FL_ALIGN_TOP}
            callback align_cb
            tooltip {Top-align the label.} xywh {328 115 20 20} type Toggle selection_color 8 labelsize 11 labelcolor 8 hide
          }
          Fl_Button {} {
            label {@-12}
            user_data {(fl_intptr_t)FL_ALIGN_BOTTOM}
            callback align_cb
            tooltip {Bottom-align the label.} xywh {353 115 20 20} type Toggle selection_color 8 labelsize 11 labelcolor 8 hide
          }
          Fl_Choice {} {
            callback align_text_image_cb
            xywh {172 115 116 20} down_box BORDER_BOX labelsize 11 textsize 11
          } {
            MenuItem {} {
              label {   Image Alignment   }
              user_data {(fl_intptr_t)0xFFFFFFFF}
              xywh {145 145 100 20} labelfont 2 labelsize 10 deactivate
            }
            MenuItem {} {
              label {image over text}
              user_data {(fl_intptr_t)FL_ALIGN_IMAGE_OVER_TEXT}
              xywh {25 25 100 20} labelsize 9
            }
            MenuItem {} {
              label {text over image}
              user_data {(fl_intptr_t)FL_ALIGN_TEXT_OVER_IMAGE}
              xywh {15 15 100 20} labelsize 9
            }
            MenuItem {} {
              label {text next to image}
              user_data {(fl_intptr_t)FL_ALIGN_TEXT_NEXT_TO_IMAGE}
              xywh {35 35 100 20} labelsize 9
            }
            MenuItem {} {
              label {image next to text}
              user_data {(fl_intptr_t)FL_ALIGN_IMAGE_NEXT_TO_TEXT}
              xywh {45 45 100 20} labelsize 9
            }
            MenuItem {} {
              label {image is backdrop}
              user_data {(fl_intptr_t)FL_ALIGN_IMAGE_BACKDROP}
              xywh {55 55 100 20} labelsize 9
            }
          }
          Fl_Choice {} {
            callback align_position_cb
            xywh {293 115 86 20} down_box BORDER_BOX labelsize 11 textsize 11
          } {
            MenuItem {} {
              label {   Inside && Outside   }
              user_data {(fl_intptr_t)0xFFFFFFFF}
              xywh {135 135 100 20} labelfont 2 labelsize 10 deactivate
            }
            MenuItem {} {
              label {top left}
              user_data {(fl_intptr_t)FL_ALIGN_TOP_LEFT}
              xywh {45 45 100 20} labelsize 9
            }
            MenuItem {} {
              label top
              user_data {(fl_intptr_t)FL_ALIGN_TOP}
              xywh {55 55 100 20} labelsize 9
            }
            MenuItem {} {
              label {top right}
              user_data {(fl_intptr_t)FL_ALIGN_TOP_RIGHT}
              xywh {65 65 100 20} labelsize 9
            }
            MenuItem {} {
              label left
              user_data {(fl_intptr_t)FL_ALIGN_LEFT}
              xywh {75 75 100 20} labelsize 9
            }
            MenuItem {} {
              label center
              user_data {(fl_intptr_t)FL_ALIGN_CENTER}
              xywh {35 35 100 20} labelsize 9
            }
            MenuItem {} {
              label right
              user_data {(fl_intptr_t)FL_ALIGN_RIGHT}
              xywh {85 85 100 20} labelsize 9
            }
            MenuItem {} {
              label {bottom left}
              user_data {(fl_intptr_t)FL_ALIGN_BOTTOM_LEFT}
              xywh {95 95 100 20} labelsize 9
            }
            MenuItem {} {
              label bottom
              user_data {(fl_intptr_t)FL_ALIGN_BOTTOM}
              xywh {105 105 100 20} labelsize 9
            }
            MenuItem {} {
              label {bottom right}
              user_data {(fl_intptr_t)FL_ALIGN_BOTTOM_RIGHT}
              xywh {115 115 100 20} labelsize 9
            }
            MenuItem {} {
              label {   Outside Alignment   }
              user_data {(fl_intptr_t)0xFFFFFFFF}
              xywh {125 125 100 20} labelfont 2 labelsize 10 deactivate
            }
            MenuItem {} {
              label {left top}
              user_data {(fl_intptr_t)FL_ALIGN_LEFT_TOP}
              xywh {135 135 100 20} labelsize 9
            }
            MenuItem {} {
              label {right top}
              user_data {(fl_intptr_t)FL_ALIGN_RIGHT_TOP}
              xywh {145 145 100 20} labelsize 9
            }
            MenuItem {} {
              label {left bottom}
              user_data {(fl_intptr_t)FL_ALIGN_LEFT_BOTTOM}
              xywh {155 155 100 20} labelsize 9
            }
            MenuItem {} {
              label {right bottom}
              user_data {(fl_intptr_t)FL_ALIGN_RIGHT_BOTTOM}
              xywh {45 45 100 20} labelsize 9
            }
          }
          Fl_Button {} {
            label {@-3square}
            user_data {(fl_intptr_t)FL_ALIGN_INSIDE}
            callback align_cb
            tooltip {Show the label inside the widget.} xywh {384 115 20 20} type Toggle selection_color 8 labelsize 11 labelcolor 8
          }
          Fl_Box {} {
            xywh {406 115 1 20} labelsize 11 resizable
          }
        }
        Fl_Group {} {
          label {Position:}
          callback position_group_cb
          xywh {95 150 314 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Input widget_x_input {
            label {X:}
            callback {if (v == LOAD) {
  if (current_widget->is_true_widget()) {
    o->value(((Widget_Node *)current_widget)->o->x());
    o->activate();
  } else o->deactivate();
} else {
  Fluid.proj.undo.checkpoint();
  widget_i = 0;
  int mod = 0;
  int v = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_true_widget()) {
      Fl_Widget *w = q->o;
      o->variables(widget_vars, q);
      v = o->value();
      w->resize(v, w->y(), w->w(), w->h());
      if (w->window()) w->window()->redraw();
      widget_i++;
      mod = 1;
    }
  }
  if (mod) {
    Fluid.proj.set_modflag(1);
    o->value(v);    // change the displayed value to the result of the last
                    // calculation. Keep the formula if it was not used.
  }
}}
            tooltip {The X position of the widget as a number or formula.
Formulas can be simple math, including the variables
x, px, sx, cx, and i} xywh {95 150 55 20} labelsize 11 align 5 textsize 11
            class {fld::widget::Formula_Input}
          }
          Fl_Input widget_y_input {
            label {Y:}
            callback {if (v == LOAD) {
  if (current_widget->is_true_widget()) {
    o->value(((Widget_Node *)current_widget)->o->y());
    o->activate();
  } else o->deactivate();
} else {
  Fluid.proj.undo.checkpoint();
  widget_i = 0;
  int mod = 0;
  int v = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_true_widget()) {
      Fl_Widget *w = q->o;
      o->variables(widget_vars, q);
      v = o->value();
      w->resize(w->x(), v, w->w(), w->h());
      if (w->window()) w->window()->redraw();
      widget_i++;
      mod = 1;
    }
  }
  if (mod) {
    Fluid.proj.set_modflag(1);
    o->value(v);
  }
}}
            tooltip {The Y position of the widget as a number or formula.
Formulas can be simple math, including the variables
y, py, sy, cy, and i} xywh {155 150 55 20} labelsize 11 align 5 textsize 11
            class {fld::widget::Formula_Input}
          }
          Fl_Input widget_w_input {
            label {Width:}
            callback {if (v == LOAD) {
  if (current_widget->is_true_widget()) {
    o->value(((Widget_Node *)current_widget)->o->w());
    o->activate();
  } else o->deactivate();
} else {
  Fluid.proj.undo.checkpoint();
  widget_i = 0;
  int mod = 0;
  int v = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_true_widget()) {
      Fl_Widget *w = q->o;
      o->variables(widget_vars, q);
      v = o->value();
      w->resize(w->x(), w->y(), v, w->h());
      if (w->window()) w->window()->redraw();
      widget_i++;
      mod = 1;
    }
  }
  if (mod) {
    Fluid.proj.set_modflag(1);
    o->value(v);
  }
}}
            tooltip {The width of the widget as a number or formula.
Formulas can be simple math, including the variables
w, pw, sw, cw, and i} xywh {215 150 55 20} labelsize 11 align 5 textsize 11
            class {fld::widget::Formula_Input}
          }
          Fl_Input widget_h_input {
            label {Height:}
            callback {if (v == LOAD) {
  if (current_widget->is_true_widget()) {
    o->value(((Widget_Node *)current_widget)->o->h());
    o->activate();
  } else o->deactivate();
} else {
  Fluid.proj.undo.checkpoint();
  widget_i = 0;
  int mod = 0;
  int v = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_true_widget()) {
      Fl_Widget *w = q->o;
      o->variables(widget_vars, q);
      v = o->value();
      w->resize(w->x(), w->y(), w->w(), v);
      if (w->window()) w->window()->redraw();
      widget_i++;
      mod = 1;
    }
  }
  if (mod) {
    Fluid.proj.set_modflag(1);
    o->value(v);
  }
}}
            tooltip {The height of the widget as a number or formula.
Formulas can be simple math, including the variables
h, ph, sh, ch, and i} xywh {275 150 55 20} labelsize 11 align 5 textsize 11
            class {fld::widget::Formula_Input}
          }
          Fl_Choice {} {
            label {Children:}
            callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Widget_Class)) {
    o->show();
    o->value(((Widget_Class_Node *)current_widget)->wc_relative);
  } else {
    o->hide();
  }
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Widget_Class)) {
      Widget_Class_Node *t = (Widget_Class_Node *)q;
      t->wc_relative = o->value();
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {When instantiating a widget class, the children can either be fixed in their original position, automatically be repositioned, or both repsositioned and resized to fit the container.} xywh {335 150 64 20} down_box BORDER_BOX labelsize 11 align 5 textsize 11
          } {
            MenuItem {} {
              label Fixed
              xywh {0 0 31 20} labelsize 11
            }
            MenuItem {} {
              label Reposition
              xywh {0 0 31 20} labelsize 11
            }
            MenuItem {} {
              label Resize
              xywh {0 0 31 20} labelsize 11
            }
          }
          Fl_Box {} {
            xywh {399 150 1 20} hide resizable
          }
        }
        Fl_Group wp_gui_flexp {
          label {Flex Parent:}
          callback {if (v == LOAD) {
  if (Flex_Node::parent_is_flex(current_widget)) {
    o->show();
    propagate_load(o, v);
  } else {
    o->hide();
  }
}}
          comment {This group is only visible if the parent is an Fl_Flex widget}
          xywh {95 150 314 20} labelfont 1 labelsize 11 align 4 hide
        } {
          Fl_Value_Input widget_flex_size {
            label {Size:}
            callback {if (v == LOAD) {
  if (Flex_Node::parent_is_flex(current_widget)) {
    o->value(Flex_Node::size(current_widget));
  }
} else {
  int mod = 0;
  int new_size = (int)o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (Flex_Node::parent_is_flex(q)) {
      Fl_Widget* w = (Fl_Widget*)q->o;
      Fl_Flex* f = (Fl_Flex*)((Flex_Node*)q->parent)->o;
      int was_fixed = f->fixed(w);
      if (new_size==0) {
        if (was_fixed) {
          f->fixed(w, 0);
          f->layout();
          widget_flex_fixed->value(0);
          mod = 1;
        }
      } else {
        int old_size = Flex_Node::size(q);
        if (old_size!=new_size || !was_fixed) {
          f->fixed(w, new_size);
          f->layout();
          widget_flex_fixed->value(1);
          mod = 1;
        }
      }
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {Fixed Width or Height for a horizontal or vertical Fl_Flex Parent.} xywh {95 150 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Check_Button widget_flex_fixed {
            label fixed
            callback {if (v == LOAD) {
  if (Flex_Node::parent_is_flex(current_widget)) {
    o->value(Flex_Node::is_fixed(current_widget));
  }
} else {
  int mod = 0;
  int new_fixed = (int)o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (Flex_Node::parent_is_flex(q)) {
      Fl_Widget* w = q->o;
      Fl_Flex* f = (Fl_Flex*)((Flex_Node*)q->parent)->o;
      int was_fixed = f->fixed(w);
      if (new_fixed==0) {
        if (was_fixed) {
          f->fixed(w, 0);
          f->layout();
          mod = 1;
        }
      } else {
        if (!was_fixed) {
          f->fixed(w, Flex_Node::size(q));
          f->layout();
          mod = 1;
        }
      }
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {If checked, the size of the widget stays fixed.} xywh {155 150 55 20} down_box DOWN_BOX labelsize 11
          }
          Fl_Box {} {
            xywh {398 150 1 20} resizable
          }
        }
        Fl_Group wp_gui_values {
          label {Values:}
          callback {if (v == LOAD) {
  if (   current_widget->is_a(Type::Flex)
      || current_widget->is_a(Type::Grid)
      || current_widget->is_a(Type::Window))
  {
    o->hide();
  } else {
    o->show();
    propagate_load(o, v);
  }
}} open
          xywh {95 185 300 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Value_Input {} {
            label {Size:}
            callback {if (v == LOAD) {
  if (!current_widget->is_a(Type::Slider)) {o->deactivate(); return;}
  o->activate();
  o->value(((Fl_Slider*)(current_widget->o))->slider_size());
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  double n = o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Slider)) {
      ((Fl_Slider*)(q->o))->slider_size(n);
      q->o->redraw();
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The size of the slider.} xywh {95 185 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Value_Input {} {
            label {Minimum:}
            callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Valuator_)) {
    o->activate();
    o->value(((Fl_Valuator*)(current_widget->o))->minimum());
  } else if (current_widget->is_a(Type::Spinner)) {
    o->activate();
    o->value(((Fl_Spinner*)(current_widget->o))->minimum());
  } else {
    o->deactivate();
    return;
  }
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  double n = o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Valuator_)) {
      ((Fl_Valuator*)(q->o))->minimum(n);
      q->o->redraw();
      mod = 1;
    } else if (q->is_a(Type::Spinner)) {
      ((Fl_Spinner*)(q->o))->minimum(n);
      q->o->redraw();
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The minimum value of the widget.} xywh {155 185 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Value_Input {} {
            label {Maximum:}
            callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Valuator_)) {
    o->activate();
    o->value(((Fl_Valuator*)(current_widget->o))->maximum());
  } else if (current_widget->is_a(Type::Spinner)) {
    o->activate();
    o->value(((Fl_Spinner*)(current_widget->o))->maximum());
  } else {
    o->deactivate();
    return;
  }
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  double n = o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Valuator_)) {
      ((Fl_Valuator*)(q->o))->maximum(n);
      q->o->redraw();
      mod = 1;
    } else if (q->is_a(Type::Spinner)) {
      ((Fl_Spinner*)(q->o))->maximum(n);
      q->o->redraw();
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The maximum value of the widget.} xywh {215 185 55 20} labelsize 11 align 5 value 1 textsize 11
          }
          Fl_Value_Input {} {
            label {Step:}
            callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Valuator_)) {
    o->activate();
    o->value(((Fl_Valuator*)(current_widget->o))->step());
  } else if (current_widget->is_a(Type::Spinner)) {
    o->activate();
    o->value(((Fl_Spinner*)(current_widget->o))->step());
  } else {
    o->deactivate();
    return;
  }
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  double n = o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Valuator_)) {
      ((Fl_Valuator*)(q->o))->step(n);
      q->o->redraw();
      mod = 1;
    } else if (q->is_a(Type::Spinner)) {
      ((Fl_Spinner*)(q->o))->step(n);
      q->o->redraw();
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The resolution of the widget value.} xywh {275 185 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Value_Input {} {
            label {Value:}
            callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Valuator_)) {
    o->activate();
    o->value(((Fl_Valuator*)(current_widget->o))->value());
  } else if (current_widget->is_button()) {
    o->activate();
    o->value(((Fl_Button*)(current_widget->o))->value());
  } else if (current_widget->is_a(Type::Spinner)) {
    o->activate();
    o->value(((Fl_Spinner*)(current_widget->o))->value());
  } else
    o->deactivate();
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  double n = o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Valuator_)) {
      ((Fl_Valuator*)(q->o))->value(n);
      mod = 1;
    } else if (q->is_button()) {
      ((Fl_Button*)(q->o))->value(n != 0);
      if (q->is_a(Type::Menu_Item)) q->redraw();
      mod = 1;
    } else if (q->is_a(Type::Spinner)) {
      ((Fl_Spinner*)(q->o))->value(n);
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The current widget value.} xywh {335 185 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Box {} {
            xywh {395 185 0 20} resizable
          }
        }
        Fl_Group wp_gui_margins {
          label {Margins:}
          callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Flex)) {
    o->show();
    propagate_load(o, v);
  } else {
    o->hide();
  }
}}
          comment {This group is only visible for Fl_Flex widgets}
          xywh {95 185 300 20} labelfont 1 labelsize 11 align 4 hide
        } {
          Fl_Value_Input {} {
            label {Left:}
            callback {flex_margin_cb(o, v, 
  [](Fl_Flex *w, Fl_Value_Input* i) -> void
  {
    int v;
    w->margin(&v, nullptr, nullptr, nullptr);
    i->value((double)v);
  }, 
  [](Fl_Flex *w, int new_value) -> int
  {
    int l, t, r, b;
    w->margin(&l, &t, &r, &b);
    if (new_value!=l) {
      w->margin(new_value, t, r, b);
      return 1;
    } else {
      return 0;
    }
  }
);}
            tooltip {Left margin in group.} xywh {95 185 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Value_Input {} {
            label {Top:}
            callback {flex_margin_cb(o, v,
  [](Fl_Flex *w, Fl_Value_Input* i) -> void
  {
    int v;
    w->margin(nullptr, &v, nullptr, nullptr);
    i->value((double)v);
  },
  [](Fl_Flex *w, int new_value)
  {
    int l, t, r, b;
    w->margin(&l, &t, &r, &b);
    if (new_value!=t) {
      w->margin(l, new_value, r, b);
      return 1;
    } else {
      return 0;
    }
  }
);}
            tooltip {Top margin in group.} xywh {155 185 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Value_Input {} {
            label {Right:}
            callback {flex_margin_cb(o, v, 
  [](Fl_Flex *w, Fl_Value_Input* i) -> void
  {
    int v;
    w->margin(nullptr, nullptr, &v, nullptr);
    i->value((double)v);
  },
  [](Fl_Flex *w, int new_value) -> int
  {
    int l, t, r, b;
    w->margin(&l, &t, &r, &b);
    if (new_value!=r) {
      w->margin(l, t, new_value, b);
      return 1;
    } else {
      return 0;
    }
  }
);}
            tooltip {Right margin in group.} xywh {215 185 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Value_Input {} {
            label {Bottom:}
            callback {flex_margin_cb(o, v, 
  [](Fl_Flex *w, Fl_Value_Input* i) -> void
  {
    int v;
    w->margin(nullptr, nullptr, nullptr, &v);
    i->value((double)v);
  },
  [](Fl_Flex *w, int new_value) -> int
  {
    int l, t, r, b;
    w->margin(&l, &t, &r, &b);
    if (new_value!=b) {
      w->margin(l, t, r, new_value);
      return 1;
    } else {
      return 0;
    }
  }
);}
            tooltip {Bottom margin in group.} xywh {275 185 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Value_Input {} {
            label {Gap:}
            callback {flex_margin_cb(o, v, 
  [](Fl_Flex *w, Fl_Value_Input* o) -> void
  {
    int v = w->gap();
    o->value((double)v);
  }, 
  [](Fl_Flex *w, int new_value) -> int
  {
    int g = w->gap();
    if (new_value!=g) {
      w->gap(new_value);
      return 1;
    } else {
      return 0;
    }
  }
);}
            tooltip {Gap between children.} xywh {335 185 55 20} labelsize 11 align 5 textsize 11
          }
          Fl_Box {} {
            xywh {395 185 0 20} resizable
          }
        }
        Fl_Group wp_gui_sizerange {
          label {Size Range:}
          callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Window)) {
    o->show();
    propagate_load(o, v);
  } else {
    o->hide();
  }
}}
          xywh {95 185 300 20} labelfont 1 labelsize 11 align 4 hide
        } {
          Fl_Value_Input {} {
            label {Minimum Size:}
            callback {if (v == LOAD) {
  if (!current_widget->is_a(Type::Window)) return;
  o->value(((Window_Node*)current_widget)->sr_min_w);
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  int n = (int)o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Window)) {
      ((Window_Node*)q)->sr_min_w = n;
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The size of the slider.} xywh {95 185 55 20} labelsize 11 align 5 maximum 2048 step 1 textsize 11
          }
          Fl_Value_Input {} {
            callback {if (v == LOAD) {
  if (!current_widget->is_a(Type::Window)) return;
  o->value(((Window_Node*)current_widget)->sr_min_h);
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  int n = (int)o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Window)) {
      ((Window_Node*)q)->sr_min_h = n;
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The minimum value of the widget.} xywh {155 185 55 20} labelsize 11 align 5 maximum 2048 step 1 textsize 11
          }
          Fl_Button {} {
            label set
            callback {if (v == LOAD) {
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Window)) {
      Window_Node *win = (Window_Node*)q;
      win->sr_min_w = win->o->w();
      win->sr_min_h = win->o->h();
      mod = 1;
    }
  }
  propagate_load(the_panel, LOAD);
  if (mod) Fluid.proj.set_modflag(1);
}}
            xywh {215 185 25 20} labelsize 11
          }
          Fl_Value_Input {} {
            label {Maximum Size:}
            callback {if (v == LOAD) {
  if (!current_widget->is_a(Type::Window)) return;
  o->value(((Window_Node*)current_widget)->sr_max_w);
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  int n = (int)o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Window)) {
      ((Window_Node*)q)->sr_max_w = n;
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The maximum value of the widget.} xywh {245 185 55 20} labelsize 11 align 5 maximum 2048 step 1 textsize 11
          }
          Fl_Value_Input {} {
            callback {if (v == LOAD) {
  if (!current_widget->is_a(Type::Window)) return;
  o->value(((Window_Node*)current_widget)->sr_max_h);
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  int n = (int)o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Window)) {
      ((Window_Node*)q)->sr_max_h = n;
      mod = 1;
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The resolution of the widget value.} xywh {305 185 55 20} labelsize 11 align 5 maximum 2048 step 1 textsize 11
          }
          Fl_Button {} {
            label set
            callback {if (v == LOAD) {
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Window)) {
      Window_Node *win = (Window_Node*)q;
      win->sr_max_w = win->o->w();
      win->sr_max_h = win->o->h();
      mod = 1;
    }
  }
  propagate_load(the_panel, LOAD);
  if (mod) Fluid.proj.set_modflag(1);
}}
            xywh {365 185 25 20} labelsize 11
          }
          Fl_Box {} {
            xywh {395 185 0 20} resizable
          }
        }
        Fl_Group {} {
          label {Shortcut:}
          callback propagate_load
          xywh {95 210 310 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Button wp_gui_shortcut {
            callback {if (v == LOAD) {
  if (current_widget->is_button())
    o->value( ((Fl_Button*)(current_widget->o))->shortcut() );
  else if (current_widget->is_a(Type::Input))
    o->value( ((Fl_Input_*)(current_widget->o))->shortcut() );
  else if (current_widget->is_a(Type::Value_Input))
    o->value( ((Fl_Value_Input*)(current_widget->o))->shortcut() );
  else if (current_widget->is_a(Type::Text_Display))
    o->value( ((Fl_Text_Display*)(current_widget->o))->shortcut() );
  else {
    o->hide();
    o->parent()->hide();
    return;
  }
  //i->default_value( i->value() ); // enable the "undo" capability of the shortcut button
  o->show();
  o->parent()->show();
  o->redraw();
} else {
  int mod = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets())
    if (q->is_button()) {
      Fl_Button* b = (Fl_Button*)(q->o);
      if (b->shortcut() != (int)o->value()) mod = 1;
      b->shortcut(o->value());
      if (q->is_a(Type::Menu_Item)) q->redraw();
    } else if (q->is_a(Type::Input)) {
      Fl_Input_* b = (Fl_Input_*)(q->o);
      if (b->shortcut() != (int)o->value()) mod = 1;
      b->shortcut(o->value());
    } else if (q->is_a(Type::Value_Input)) {
      Fl_Value_Input* b = (Fl_Value_Input*)(q->o);
      if (b->shortcut() != (int)o->value()) mod = 1;
      b->shortcut(o->value());
    } else if (q->is_a(Type::Text_Display)) {
      Fl_Text_Display* b = (Fl_Text_Display*)(q->o);
      if (b->shortcut() != (int)o->value()) mod = 1;
      b->shortcut(o->value());
    }
  if (mod) Fluid.proj.set_modflag(1);
}}
            comment {This is a special button that grabs keystrokes directly}
            tooltip {The shortcut key for the widget.
Use 'Backspace' key to clear.} xywh {95 210 310 20} box DOWN_BOX color 7 selection_color 12 labelsize 11 when 1
            code0 {\#include <FL/Fl_Shortcut_Button.H>}
            class Fl_Shortcut_Button
          }
        }
        Fl_Group wp_gui_xclass {
          label {X Class:}
          callback propagate_load
          xywh {95 235 300 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Input {} {
            label {:}
            callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Window)) {
    o->show();
    o->parent()->show();
    o->value(((Window_Node *)current_widget)->xclass);
  } else {
    o->hide();
    o->parent()->hide(); // hides the "X Class:" label as well
  }
} else {
  int mod = 0;
  Fluid.proj.undo.checkpoint();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Window)) {
      mod = 1;
      Window_Node *wt = (Window_Node *)q;
      storestring(o->value(), wt->xclass);
      ((Fl_Window*)(wt->o))->xclass(wt->xclass);
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The X resource class.} xywh {95 235 95 20} labelfont 1 labelsize 11 textsize 11 resizable
          }
          Fl_Light_Button {} {
            label Border
            callback {if (v == LOAD) {
  if (!current_widget->is_a(Type::Window)) {o->hide(); return;}
  o->show();
  o->value(((Fl_Window*)(current_widget->o))->border());
} else {
  Fluid.proj.undo.checkpoint();
  ((Fl_Window*)(current_widget->o))->border(o->value());
  Fluid.proj.set_modflag(1);
}}
            tooltip {Add a border around the window.} xywh {195 235 60 20} selection_color 1 labelsize 11
          }
          Fl_Light_Button {} {
            label Modal
            callback {if (v == LOAD) {
  if (!current_widget->is_a(Type::Window)) {o->hide(); return;}
  o->show();
  o->value(((Window_Node *)current_widget)->modal);
} else {
  Fluid.proj.undo.checkpoint();
  ((Window_Node *)current_widget)->modal = o->value();
  Fluid.proj.set_modflag(1);
}}
            tooltip {Make the window modal.} xywh {260 235 55 20} selection_color 1 labelsize 11
          }
          Fl_Light_Button {} {
            label Nonmodal
            callback {if (v == LOAD) {
  if (!current_widget->is_a(Type::Window)) {o->hide(); return;}
  o->show();
  o->value(((Window_Node *)current_widget)->non_modal);
} else {
  Fluid.proj.undo.checkpoint();
  ((Window_Node *)current_widget)->non_modal = o->value();
  Fluid.proj.set_modflag(1);
}}
            tooltip {Make the window non-modal.} xywh {320 235 75 20} selection_color 1 labelsize 11 align 148
          }
        }
        Fl_Group wp_gui_attributes {
          label {Attributes:}
          callback propagate_load
          xywh {95 260 305 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Light_Button {} {
            label Visible
            callback {if (v == LOAD) {
  o->value(current_widget->o->visible());
  if (current_widget->is_a(Type::Window)) o->deactivate();
  else o->activate();
} else {
  int mod = 0;
  int n = o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (!mod) {
      mod = 1;
      Fluid.proj.undo.checkpoint();
    }
    n ? q->o->show() : q->o->hide();
    q->redraw();
    if (n && q->parent && q->parent->type_name()) {
      if (q->parent->is_a(Type::Tabs)) {
        ((Fl_Tabs *)q->o->parent())->value(q->o);
      } else if (q->parent->is_a(Type::Wizard)) {
        ((Fl_Wizard *)q->o->parent())->value(q->o);
      }
    }
  }
  if (mod) {
    Fluid.proj.set_modflag(1);
    redraw_browser();
  }
}}
            tooltip {Show the widget.} xywh {95 260 60 20} selection_color 1 labelsize 11
          }
          Fl_Light_Button {} {
            label Active
            callback {if (v == LOAD) {
  o->value(current_widget->o->active());
  if (current_widget->is_a(Type::Window)) o->deactivate();
  else o->activate();
} else {
  int mod = 0;
  int n = o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (!mod) {
      mod = 1;
      Fluid.proj.undo.checkpoint();
    }
    n ? q->o->activate() : q->o->deactivate();
    q->redraw();
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {Activate the widget.} xywh {160 260 60 20} selection_color 1 labelsize 11
          }
          Fl_Light_Button {} {
            label Resizable
            callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Menu_Item)) {o->deactivate(); return;}
  if (numselected > 1) {o->deactivate(); return;}
  o->activate();
  o->value(current_widget->resizable());
} else {
  Fluid.proj.undo.checkpoint();
  current_widget->resizable(o->value());
  Fluid.proj.set_modflag(1);
}}
            tooltip {Make the widget resizable.} xywh {225 260 75 20} selection_color 1 labelsize 11 when 1
          }
          Fl_Light_Button {} {
            label Hotspot
            callback {if (v == LOAD) {
  if (numselected > 1) {o->deactivate(); return;}
  if (current_widget->is_a(Type::Menu_Item)) o->label("divider");
  else o->label("hotspot");
  o->activate();
  o->value(current_widget->hotspot());
} else {
  Fluid.proj.undo.checkpoint();
  current_widget->hotspot(o->value());
  if (current_widget->is_a(Type::Menu_Item)) {
    current_widget->redraw();
    return;
  }
  if (o->value()) {
    Node *p = current_widget->parent;
    if (!p || !p->is_widget()) return;
    while (!p->is_a(Type::Window)) p = p->parent;
    for (Node *q = p->next; q && q->level > p->level; q = q->next) {
      if (q->is_widget() && q != current_widget)
        ((Widget_Node*)q)->hotspot(0);
    }
  }
  Fluid.proj.set_modflag(1);
}}
            tooltip {Center the window under this widget.} xywh {305 260 70 20} selection_color 1 labelsize 11 when 1
          }
          Fl_Box {} {
            xywh {395 260 0 20} labelsize 11 resizable
          }
        }
        Fl_Input wp_gui_tooltip {
          label {Tooltip:}
          callback {if (v == LOAD) {
  if (current_widget->is_widget()) {
    o->activate();
    o->value(((Widget_Node*)current_widget)->tooltip());
  } else {
    o->deactivate();
  }
} else {
  int mod = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->tooltip(o->value());
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
          tooltip {The tooltip text for the widget.
Use Ctrl-J for newlines.} xywh {95 285 310 20} labelfont 1 labelsize 11 textsize 11
        }
        Fl_Box {} {
          xywh {95 305 300 5} hide resizable
        }
      }
      Fl_Group wp_style_tab {
        label Style
        callback propagate_load open
        xywh {10 30 400 330} labelsize 11 when 0 hide
      } {
        Fl_Group wp_style_label {
          label {Label Font:}
          callback propagate_load open
          xywh {99 40 305 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Choice {} {
            callback {if (v == LOAD) {
  int n = current_widget->o->labelfont();
  if (n > 15) n = 0;
  o->value(n);
} else {
  int mod = 0;
  int n = o->value();
  if (n <= 0) n = Fluid.proj.layout->labelfont;
  if (n <= 0) n = FL_HELVETICA;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->o->labelfont(n);
    q->redraw();
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}} open
            tooltip {The style of the label text.} xywh {99 40 148 20} box THIN_UP_BOX down_box BORDER_BOX labelfont 1 labelsize 11 textsize 11 resizable
            code0 {extern Fl_Menu_Item fontmenu[];}
            code1 {o->menu(fontmenu);}
          } {}
          Fl_Value_Input {} {
            callback {int n;
if (v == LOAD) {
  n = current_widget->o->labelsize();
} else {
  int mod = 0;
  n = int(o->value());
  if (n <= 0) n = Fluid.proj.layout->labelsize;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->o->labelsize(n);
    q->redraw();
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}
o->value(n);}
            tooltip {The size of the label text.} xywh {247 40 49 20} labelsize 11 maximum 100 step 1 value 14 textsize 11
          }
          Fl_Button w_labelcolor {
            label {Label Color}
            callback {Fl_Color c = current_widget->o->labelcolor();
if (v != LOAD) {
  Fl_Color d = fl_show_colormap(c);
  if (d == c) return;
  c = d;
  labelcolor_common(c);
}
o->color(c);
o->labelcolor(fl_contrast(FL_BLACK,c));
o->redraw();}
            tooltip {The color of the label text.} xywh {296 40 90 20} labelsize 11
          }
          Fl_Menu_Button {} {
            callback {Fl_Color c = current_widget->o->labelcolor();
if (v != LOAD) {
  Fl_Color d = (Fl_Color)(o->mvalue()->argument());
  if (d == c) return;
  c = d;
  labelcolor_common(c);
  w_labelcolor->color(c); 
  w_labelcolor->labelcolor(fl_contrast(FL_BLACK,c)); 
  w_labelcolor->redraw();
}} open
            xywh {386 40 18 20}
            code0 {extern Fl_Menu_Item colormenu[];}
            code1 {o->menu(colormenu);}
          } {}
        }
        Fl_Group wp_style_box {
          label {Box:}
          callback propagate_load open
          xywh {99 65 305 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Choice {} {
            callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Menu_Item)) {o->deactivate(); return;} else o->activate();
  int n = current_widget->o->box(); 
  if (!n) n = ZERO_ENTRY;
  for (int j = 0; j < 72 /*int(sizeof(boxmenu)/sizeof(*boxmenu))*/; j++)
    if (boxmenu[j].argument() == n) {o->value(j); break;}
} else {
  int mod = 0;
  int m = o->value();
  int n = int(boxmenu[m].argument());
  if (!n) return; // should not happen
  if (n == ZERO_ENTRY) n = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->o->box((Fl_Boxtype)n);
    q->redraw();
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}} open
            tooltip {The "up" box of the widget.} xywh {100 65 196 20} box THIN_UP_BOX down_box BORDER_BOX labelfont 1 labelsize 11 textsize 11 resizable
            code0 {extern Fl_Menu_Item boxmenu[];}
            code1 {o->menu(boxmenu);}
          } {}
          Fl_Button w_color {
            label Color
            callback {Fl_Color c = current_widget->o->color();
if (v == LOAD) {
  if (current_widget->is_a(Type::Menu_Item)) {
    o->deactivate();
  } else {
    o->activate();
  }
} else {
  Fl_Color d = fl_show_colormap(c);
  if (d == c) return;
  c = d;
  color_common(c);
}
o->color(c);
o->labelcolor(fl_contrast(FL_BLACK,c));
o->redraw();}
            tooltip {The background color of the widget.} xywh {296 65 90 20} labelsize 11
          }
          Fl_Menu_Button {} {
            callback {Fl_Color c = current_widget->o->color();
if (v == LOAD) {
  if (current_widget->is_a(Type::Menu_Item)) {o->deactivate(); return;} else o->activate();
} else {
  Fl_Color d = (Fl_Color)(o->mvalue()->argument());
  if (d == c) return;
  c = d;
  color_common(c);
  w_color->color(c);
  w_color->labelcolor(fl_contrast(FL_BLACK,c));
  w_color->redraw();
}} open
            xywh {386 65 18 20}
            code0 {extern Fl_Menu_Item colormenu[];}
            code1 {o->menu(colormenu);}
          } {}
        }
        Fl_Group wp_style_downbox {
          label {Down Box:}
          callback propagate_load open
          xywh {99 90 305 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Choice {} {
            callback {if (v == LOAD) {
  int n;
  if (current_widget->is_a(Type::Button))
    n = ((Fl_Button*)(current_widget->o))->down_box();
  else if (current_widget->is_a(Type::Input_Choice))
    n = ((Fl_Input_Choice*)(current_widget->o))->down_box();
  else if (current_widget->is_a(Type::Menu_Manager_))
    n = ((Fl_Menu_*)(current_widget->o))->down_box();
  else {
    o->deactivate(); return;
  }
  o->activate();
  if (!n) n = ZERO_ENTRY;
  for (int j = 0; j < 72 /*int(sizeof(boxmenu)/sizeof(*boxmenu))*/; j++)
    if (boxmenu[j].argument() == n) {o->value(j); break;}
} else {
  int mod = 0;
  int m = o->value();
  int n = int(boxmenu[m].argument());
  if (!n) return; // should not happen
  if (n == ZERO_ENTRY) n = 0;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Button)) {
      ((Fl_Button*)(q->o))->down_box((Fl_Boxtype)n);
      if (((Fl_Button*)(q->o))->value()) q->redraw();
    } else if (q->is_a(Type::Input_Choice)) {
      ((Fl_Input_Choice*)(q->o))->down_box((Fl_Boxtype)n);
    } else if (q->is_a(Type::Menu_Manager_)) {
      ((Fl_Menu_*)(q->o))->down_box((Fl_Boxtype)n);
    }
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}} open
            tooltip {The "down" box of the widget.} xywh {99 90 197 20} box THIN_UP_BOX down_box BORDER_BOX labelfont 1 labelsize 11 textsize 11 resizable
            code0 {extern Fl_Menu_Item boxmenu[];}
            code1 {o->menu(boxmenu);}
          } {}
          Fl_Button w_selectcolor {
            label {Select Color}
            callback {Fl_Color c = current_widget->o->selection_color();
if (v == LOAD) {
  if (current_widget->is_a(Type::Menu_Item)) {
    o->deactivate();
    return;
  } else {
    o->activate();
  }
} else {
  Fl_Color d = fl_show_colormap(c);
  if (d == c) return;
  c = d;
  color2_common(c);
}
o->color(c);
o->labelcolor(fl_contrast(FL_BLACK,c));
o->redraw();}
            tooltip {The selection color of the widget.} xywh {296 90 90 20} labelsize 11
          }
          Fl_Menu_Button {} {
            callback {Fl_Color c = current_widget->o->selection_color();
if (v == LOAD) {
  if (current_widget->is_a(Type::Menu_Item)) {
    o->deactivate();
    return;
  } else {
    o->activate();
  }
} else {
  Fl_Color d = (Fl_Color)(o->mvalue()->argument());
  if (d == c) return;
  c = d;
  color2_common(c);
  w_selectcolor->color(c);
  w_selectcolor->labelcolor(fl_contrast(FL_BLACK,c));
  w_selectcolor->redraw();
}} open
            xywh {386 90 18 20}
            code0 {extern Fl_Menu_Item colormenu[];}
            code1 {o->menu(colormenu);}
          } {}
        }
        Fl_Group wp_style_text {
          label {Text Font:}
          callback propagate_load open
          xywh {99 115 305 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Choice {} {
            callback {Fl_Font n; int s; Fl_Color c;
if (v == LOAD) {
  if (!current_widget->textstuff(0,n,s,c)) {o->deactivate(); return;}
  o->activate();
  if (n > 15) n = FL_HELVETICA;
  o->value(n);
} else {
  int mod = 0;
  n = (Fl_Font)o->value();
  if (n <= 0) n = Fluid.proj.layout->textfont;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->textstuff(1,n,s,c);
    q->o->redraw();
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}} open
            tooltip {The value text style.} xywh {99 115 148 20} box DOWN_BOX down_box BORDER_BOX labelfont 1 labelsize 11 textsize 11 resizable
            code0 {extern Fl_Menu_Item fontmenu[];}
            code1 {o->menu(fontmenu);}
          } {}
          Fl_Value_Input {} {
            callback {Fl_Font n; int s; Fl_Color c;
if (v == LOAD) {
  if (!current_widget->textstuff(0,n,s,c)) {o->deactivate(); return;}
  o->activate();
} else {
  int mod = 0;
  s = int(o->value());
  if (s <= 0) s = Fluid.proj.layout->textsize;
  if (s <= 0) s = Fluid.proj.layout->labelsize;
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->textstuff(2,n,s,c);
    q->o->redraw();
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}
o->value(s);}
            tooltip {The value text size.} xywh {247 115 49 20} labelsize 11 maximum 100 step 1 value 14 textsize 11
          }
          Fl_Button w_textcolor {
            label {Text Color}
            callback {Fl_Font n; int s; Fl_Color c;
if (v == LOAD) {
  if (!current_widget->textstuff(0,n,s,c)) {
    o->deactivate();
    return;
  }
  o->activate();
} else {
  c = o->color();
  Fl_Color d = fl_show_colormap(c);
  if (d == c) return;
  c = d;
  textcolor_common(c);
}
o->color(c);
o->labelcolor(fl_contrast(FL_BLACK,c));
o->redraw();}
            tooltip {The value text color.} xywh {296 115 90 20} labelsize 11
          }
          Fl_Menu_Button {} {
            callback {Fl_Font n; int s; Fl_Color c;
if (v == LOAD) {
  if (!current_widget->textstuff(0,n,s,c)) {
    o->deactivate();
    return;
  }
  o->activate();
} else {
  c = o->color();
  Fl_Color d = (Fl_Color)(o->mvalue()->argument());
  if (d == c) return;
  c = d;
  textcolor_common(c);
  w_textcolor->color(c);
  w_textcolor->labelcolor(fl_contrast(FL_BLACK,c));
  w_textcolor->redraw();
}} open
            xywh {386 115 18 20}
            code0 {extern Fl_Menu_Item colormenu[];}
            code1 {o->menu(colormenu);}
          } {}
        }
        Fl_Group {} {
          label {Label Margin:}
          callback propagate_load open
          xywh {99 150 242 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Value_Input {} {
            label {Horizontal:}
            callback {int s;
if (v == LOAD) {
  if (!current_widget->is_true_widget()) {
    o->deactivate();
    o->value(0);
  } else {
    o->activate();
    o->value(((Widget_Node*)current_widget)->o->horizontal_label_margin());
  }
} else {
  int mod = 0;
  s = int(o->value());
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_true_widget()) {
      if (q->o->horizontal_label_margin() != s) {
        q->o->horizontal_label_margin(s);
        if (!(q->o->align() & FL_ALIGN_INSIDE) && q->o->window())
          q->o->window()->damage(FL_DAMAGE_EXPOSE); // outside labels
        q->o->redraw();
        mod = 1;
      }
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {Spacing between label and the horizontally aligned side of the widget.} xywh {99 150 55 20} labelsize 11 align 5 minimum -127 maximum 128 step 1 textsize 11
          }
          Fl_Value_Input {} {
            label {Vertical:}
            callback {int s;
if (v == LOAD) {
  if (!current_widget->is_true_widget()) {
    o->deactivate();
    o->value(0);
  } else {
    o->activate();
    o->value(((Widget_Node*)current_widget)->o->vertical_label_margin());
  }
} else {
  int mod = 0;
  s = int(o->value());
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_true_widget()) {
      if (q->o->vertical_label_margin() != s) {
        q->o->vertical_label_margin(s);
        if (!(q->o->align() & FL_ALIGN_INSIDE) && q->o->window())
          q->o->window()->damage(FL_DAMAGE_EXPOSE); // outside labels
        q->o->redraw();
        mod = 1;
      }
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {Spacing between label and the vertically aligned side of the widget.} xywh {159 150 55 20} labelsize 11 align 5 minimum -127 maximum 127 step 1 textsize 11
          }
          Fl_Value_Input {} {
            label {Image Gap:}
            callback {int s;
if (v == LOAD) {
  if (!current_widget->is_true_widget()) {
    o->deactivate();
    o->value(0);
  } else {
    o->activate();
    o->value(((Widget_Node*)current_widget)->o->label_image_spacing());
  }
} else {
  int mod = 0;
  s = int(o->value());
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_true_widget()) {
      if (q->o->label_image_spacing() != s) {
        q->o->label_image_spacing(s);
        if (!(q->o->align() & FL_ALIGN_INSIDE) && q->o->window())
          q->o->window()->damage(FL_DAMAGE_EXPOSE); // outside labels
        q->o->redraw();
        mod = 1;
      }
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {Gap between label image and text in pixels} xywh {219 150 55 20} labelsize 11 align 5 maximum 255 step 1 textsize 11
          }
          Fl_Box {} {
            xywh {281 150 60 20} labelsize 11 hide resizable
          }
        }
        Fl_Light_Button {} {
          label Compact
          callback {if (v == LOAD) {
  uchar n;
  if (current_widget->is_a(Type::Button) && !current_widget->is_a(Type::Menu_Item)) {
    n = ((Fl_Button*)(current_widget->o))->compact();
    o->value(n);
    o->show();
  } else {
    o->hide();
  }
} else {
  int mod = 0;
  uchar n = (uchar)o->value();
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    if (q->is_a(Type::Button) && !q->is_a(Type::Menu_Item)) {
      uchar v = ((Fl_Button*)(q->o))->compact();
      if (n != v) {
        if (!mod) {
          mod = 1;
          Fluid.proj.undo.checkpoint();
        }
        ((Fl_Button*)(q->o))->compact(n);
        q->redraw();
      }
    }
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
          tooltip {use compact box types for closely set buttons} xywh {99 175 90 20} selection_color 1 labelsize 11
        }
        Fl_Box {} {
          xywh {195 205 40 40} labelsize 11 resizable
        }
      }
      Fl_Group wp_cpp_tab {
        label {C++}
        callback propagate_load
        xywh {10 30 400 330} labelsize 11 when 0 hide
      } {
        Fl_Group wp_cpp_class {
          label {Class:}
          callback propagate_load open
          xywh {95 40 310 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Input {} {
            user_data 4
            callback {if (v == LOAD) {
    if (current_widget->is_a(Type::Menu_Item)) {
      o->deactivate(); 
    } else {
      o->activate();
      o->value(current_widget->subclass());
    }
  } else {
    int mod = 0;
    const char *c = o->value();
    for (Widget_Node *t: Fluid.proj.tree.all_selected_widgets()) {
      t->subclass(c);
      mod = 1;
    }
    if (mod) Fluid.proj.set_modflag(1);
  }}
            tooltip {The widget subclass.} xywh {95 40 172 20} labelfont 1 labelsize 11 textfont 4 textsize 11 resizable
          }
          Fl_Choice {} {
            callback {static Fl_Menu_Item empty_type_menu[] = {
    {"Normal",0,nullptr,(void*)nullptr},
    {nullptr}};

  if (v == LOAD) {
    Fl_Menu_Item* m = current_widget->subtypes();
    if (!m) {
      o->menu(empty_type_menu);
      o->value(0);
      o->deactivate();
    } else {
      o->menu(m);
      int j;
      for (j = 0;; j++) {
        if (!m[j].text) {j = 0; break;}
        if (current_widget->is_a(Type::Spinner)) {
          if (m[j].argument() == ((Fl_Spinner*)current_widget->o)->type()) break;
        } else {
          if (m[j].argument() == current_widget->o->type()) break;
        }
      }
      o->value(j);
      o->activate();
    }
    o->redraw();
  } else {
    int mod = 0;
    int n = int(o->mvalue()->argument());
    Fl_Menu_Item* m = current_widget->subtypes();
    for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
      if (q->subtypes()==m) {
        if (q->is_a(Type::Spinner))
          ((Fl_Spinner*)q->o)->type(n);
        else if (q->is_a(Type::Flex))
          ((Flex_Node*)q)->change_subtype_to(n);
        else
          q->o->type(n);
        q->redraw();
        mod = 1;
      }
    }
    if (mod) Fluid.proj.set_modflag(1);
  }} open
            tooltip {The widget subtype.} xywh {267 40 138 20} box THIN_UP_BOX down_box BORDER_BOX labelsize 11 textsize 11
          } {}
        }
        Fl_Group wp_cpp_name {
          label {Name:}
          callback propagate_load open
          xywh {95 65 310 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Input {} {
            callback {if (v == LOAD) {
    static char buf[1024];
    if (numselected != 1) {
      snprintf(buf, sizeof(buf), "Widget Properties (%d widgets)", numselected);
      o->hide();
    } else {
      o->value(current_widget->name());
      o->show();
      snprintf(buf, sizeof(buf), "%s Properties", current_widget->title());
    }

    the_panel->label(buf);
  } else {
    if (numselected == 1) {
      current_widget->name(o->value());
      // I don't update window title, as it probably is being closed
      // and wm2 (a window manager) barfs if you retitle and then
      // hide a window:
      // ((Fl_Window*)(o->parent()->parent()->parent()))->label(current_widget->title());
    }
  }}
            tooltip {The name of the widget.} xywh {95 65 235 20} labelfont 1 labelsize 11 textsize 11 resizable
          }
          Fl_Choice {} {
            callback {if (v == LOAD) {
  o->value(current_widget->public_);
  if (current_widget->is_in_class()) o->show(); else o->hide();
} else {
  int mod = 0;
  for (Widget_Node *w: Fluid.proj.tree.all_selected_widgets()) {
    if (w->is_in_class()) {
      w->public_ = o->value();
    } else {
      // if this is not in a class, it can be only private or public
      w->public_ = (o->value()>0);
    }
    mod = 1;
  }
  if (mod) {
    Fluid.proj.set_modflag(1);
    redraw_browser();
  }
}} open
            tooltip {Change member access attribute.} xywh {330 65 75 20} down_box BORDER_BOX labelsize 11 when 1 textsize 11
          } {
            MenuItem {} {
              label private
              user_data 0 user_data_type long
              xywh {0 0 100 20} labelsize 11
            }
            MenuItem {} {
              label public
              user_data 1 user_data_type long
              xywh {0 0 100 20} labelsize 11
            }
            MenuItem {} {
              label protected
              user_data 2 user_data_type long
              xywh {0 0 100 20} labelsize 11
            }
          }
          Fl_Choice {} {
            callback name_public_cb open
            tooltip {Change widget accessibility.} xywh {330 65 75 20} down_box BORDER_BOX labelsize 11 when 1 textsize 11 hide
          } {
            MenuItem {} {
              label local
              user_data 0 user_data_type long
              xywh {10 10 100 20} labelsize 11
            }
            MenuItem {} {
              label global
              user_data 1 user_data_type long
              xywh {10 10 100 20} labelsize 11
            }
          }
        }
        Fl_Input {v_input[0]} {
          label {Extra Code:}
          user_data 0
          callback {int n = fl_int(o->user_data());
  if (v == LOAD) {
    o->value(current_widget->extra_code(n));
  } else {
    int mod = 0;
    const char *c = o->value();
    const char *d = c_check(c&&c[0]=='\#' ? c+1 : c);
    if (d) {fl_message("Error in %s: %s",o->label(),d); haderror = 1; return;}
    for (Widget_Node *w: Fluid.proj.tree.all_selected_widgets()) {
      w->extra_code(n,c);
      mod = 1;
    }
    if (mod) Fluid.proj.set_modflag(1);
  }}
          tooltip {Extra initialization code for the widget.} xywh {95 90 310 20} labelfont 1 labelsize 11 textfont 4 textsize 11
        }
        Fl_Input {v_input[1]} {
          user_data 1
          callback {cb_v_input(o, v);}
          tooltip {Extra initialization code for the widget.} xywh {95 110 310 20} labelsize 11 textfont 4 textsize 11
        }
        Fl_Input {v_input[2]} {
          user_data 2
          callback {cb_v_input(o, v);}
          tooltip {Extra initialization code for the widget.} xywh {95 130 310 20} labelsize 11 textfont 4 textsize 11
        }
        Fl_Input {v_input[3]} {
          user_data 3
          callback {cb_v_input(o, v);}
          tooltip {Extra initialization code for the widget.} xywh {95 150 310 20} labelsize 11 textfont 4 textsize 11
        }
        Fl_Tile {} {
          callback {wComment->do_callback(wComment, v);
wCallback->do_callback(wCallback, v);} open
          xywh {95 175 310 130} resizable
        } {
          Fl_Group {} {open
            xywh {95 175 310 48} box FLAT_BOX
          } {
            Fl_Text_Editor wComment {
              label {Comment:}
              callback {if (v == LOAD) {
    const char *cmttext = current_widget->comment();
    o->buffer()->text( cmttext ? cmttext : "" );
  } else {
    int mod = 0;
    char *c = o->buffer()->text();
    for (Node *n: Fluid.proj.tree.all_selected_nodes()) {
      n->comment(c);
      mod = 1;
    }
    if (mod) Fluid.proj.set_modflag(1);
    free(c);
  }}
              tooltip {Write a comment that will appear in the source code and in the widget tree overview.} xywh {95 175 310 45} box DOWN_BOX labelfont 1 labelsize 11 align 4 when 1 textfont 6 textsize 11 textcolor 59 resizable
              code0 {wComment->buffer(new Fl_Text_Buffer());}
            }
          }
          Fl_Group {} {open
            xywh {95 223 310 82} box FLAT_BOX
          } {
            Fl_Text_Editor wCallback {
              label {Callback:}
              callback {if (v == LOAD) {
    const char *cbtext = current_widget->callback();
    o->buffer()->text( cbtext ? cbtext : "" );
  } else {
    int mod = 0;
    char *c = o->buffer()->text();
    const char *d = c_check(c);
    if (d) {
      fl_message("Error in callback: %s",d);
      if (o->window()) o->window()->make_current();
      haderror = 1;
    }
    for (Node *n: Fluid.proj.tree.all_selected_nodes()) {
      n->callback(c);
      mod = 1;
    }
    if (mod) Fluid.proj.set_modflag(1);
    free(c);
  }}
              tooltip {The callback function or code for the widget. Use the variable name 'o' to access the Widget pointer and 'v' to access the user value.} xywh {95 225 310 80} box DOWN_BOX labelfont 1 labelsize 11 align 4 textfont 4 textsize 11 resizable
              code0 {\#include "widgets/Code_Editor.h"}
              class {fld::widget::Code_Editor}
            }
          }
        }
        Fl_Group wp_cpp_callback {
          label {User Data:}
          callback propagate_load open
          xywh {95 310 310 20} labelfont 1 labelsize 11 align 4
        } {
          Fl_Input {} {
            callback {if (v == LOAD) {
  o->value(current_widget->user_data());
} else {
  int mod = 0;
  const char *c = o->value();
  const char *d = c_check(c);
  if (d) {fl_message("Error in user_data: %s",d); haderror = 1; return;}
  for (Node *n: Fluid.proj.tree.all_selected_nodes()) {
    n->user_data(c);
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}}
            tooltip {The user data to pass into the callback code.} xywh {95 310 158 20} labelfont 1 labelsize 11 textfont 4 textsize 11 resizable
          }
          Fl_Menu_Button {} {
            label When
            callback {if (v == LOAD) {
  if (current_widget->is_a(Type::Menu_Item)) {o->deactivate(); return;} else o->activate();
  int n = current_widget->o->when();
  set_whenmenu(n);
  w_when_box->copy_label(when_symbol_name(n));
} else {
  int mod = 0;
  int n = 0;
  if (o->mvalue() && ((o->mvalue()->flags & FL_MENU_TOGGLE) == 0) ) {
    n = (int)o->mvalue()->argument();
    set_whenmenu(n);
  } else {
    if (whenmenu[0].value()) n |= FL_WHEN_CHANGED;
    if (whenmenu[1].value()) n |= FL_WHEN_NOT_CHANGED;
    if (whenmenu[2].value()) n |= FL_WHEN_RELEASE;
    if (whenmenu[3].value()) n |= FL_WHEN_ENTER_KEY;
    if (whenmenu[4].value()) n |= FL_WHEN_CLOSED;
  }
  w_when_box->copy_label(when_symbol_name(n));
  for (Widget_Node *q: Fluid.proj.tree.all_selected_widgets()) {
    q->o->when(n);
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}} open
            tooltip {When to call the callback function.} xywh {260 310 145 20} box THIN_UP_BOX down_box BORDER_BOX labelfont 1 labelsize 11 when 1 textsize 11
            code0 {extern Fl_Menu_Item whenmenu[];}
            code1 {o->menu(whenmenu);}
          } {}
        }
        Fl_Group {} {
          label {Type:}
          callback propagate_load open
          xywh {95 332 310 26} labelfont 1 labelsize 11 align 4
        } {
          Fl_Input_Choice {} {
            callback {static const char *dflt = "void*";
if (v == LOAD) {
  const char *c = current_widget->user_data_type();
  if (!c) c = dflt;
  o->value(c);
} else {
  int mod = 0;
  const char *c = o->value();
  const char *d = c_check(c);
  if (!*c) o->value(dflt);
  else if (!strcmp(c,dflt)) c = nullptr;
  if (!d) {
    if (c && *c && c[strlen(c)-1] != '*' && strcmp(c,"long"))
      d = "must be pointer or long";
  }
  if (d) {fl_message("Error in type: %s",d); haderror = 1; return;}
  for (Node *q: Fluid.proj.tree.all_selected_nodes()) {
    q->user_data_type(c);
    mod = 1;
  }
  if (mod) Fluid.proj.set_modflag(1);
}} open
            tooltip {The type of the user data.} xywh {95 335 158 20} labelfont 1 labelsize 11 textfont 4 textsize 11 resizable
          } {
            MenuItem {} {
              label {void*}
              xywh {0 0 31 20} labelfont 4 labelsize 11
            }
            MenuItem {} {
              label long
              xywh {0 0 31 20} labelfont 4 labelsize 11
            }
          }
          Fl_Box w_when_box {
            label FL_WHEN_NEVER
            xywh {260 332 145 26} box FLAT_BOX selection_color 1 labelsize 8 align 209
          }
        }
      }
      Fl_Group widget_tab_grid {
        label Grid
        callback {o->callback((Fl_Callback*)propagate_load);} open
        xywh {10 30 400 330} labelsize 11 hide
        class Grid_Tab
      } {}
      Fl_Group widget_tab_grid_child {
        label {Grid Child}
        callback {o->callback((Fl_Callback*)propagate_load);} open
        xywh {10 30 400 330} labelsize 11 hide
        class Grid_Child_Tab
      } {}
    }
    Fl_Tabs widget_tabs_repo {
      xywh {10 10 400 350} hide
      code0 {o->hide();}
    } {
      Fl_Group {} {open
        xywh {10 30 400 330} resizable
      } {}
    }
    Fl_Group {} {
      xywh {10 370 400 20} labelsize 11
    } {
      Fl_Button wLiveMode {
        label {Live &Resize}
        callback live_mode_cb
        tooltip {Create a live duplicate of the selected widgets to test resizing and menu behavior.} xywh {10 370 80 20} type Toggle labelsize 10
      }
      Fl_Button overlay_button {
        label {Hide &Overlays}
        callback overlay_cb
        tooltip {Hide the widget overlay box.} xywh {94 370 80 20} labelsize 10
      }
      Fl_Box {} {
        comment {Hidden resizable box}
        xywh {258 370 72 20} labelsize 11 hide resizable
      }
      Fl_Return_Button {} {
        label Close
        callback ok_cb
        xywh {330 370 80 20} labelsize 11
      }
    }
  }
}
