/**

 \page page_appendices Appendices

 \tableofcontents

 \section appendix_app_widget Widget Properties Panel

 ## The Widget Properties Panel ##

 \image html widget_panel.png "Widget Properties"
 \image latex widget_panel.png "Widget Properties"

 This panel is used to edit the properties of the currently selected widgets.
 One or more widgets can be selected at the same time, and most attributes
 changes will be applied to the entire selection.
 Depending on the selected widget types, some properties may
 be grayed out or may not be visible.

 All changes in the widget panel are immediately applied to all selected
 widgets and their effect can be seen in the project window. It can be very
 useful to keep the *Source View* window open at all times. All code changes
 appear instantly for all generated files if *Auto-Refresh* is active.

 FLUID generates only code for properties that differ from their default
 setting. If a widget class is derived from another class, FLUID can't know
 the defaults and will generate code for all attribute instead.

 \image html wLiveMode.png
 \image latex wLiveMode.png

 Correctly resizing a window can be a complex task. It is easier to check
 resizing behavior on a more local level first.
 To use *Live Resize*, select any group or window in your project. FLUID creates
 a resizable clone of that part of your design to try out resizing behavior
 of that group only.

 <!-- ---------------------------------------------------------------------- -->
 ## The GUI Tab ##

 \image html wp_gui_tab.png
 \image latex wp_gui_tab.png

 The widget panel has three standard tabs that apply to all widgets. Some widget
 types, `Fl_Grid` and children of `Fl_Grid`, will create additional
 tabs with more options.

 The GUI tab controls basic GUI settings, including label text and widget size.

 \image html wp_gui_label.png
 \image latex wp_gui_label.png

 The *Label* field can be any Unicode string and is stored as a static text.
 If internationalization is enabled, the corresponding modifiers are
 added. Labels can span multiple lines by pressing `Ctrl-J` to insert a new-line
 character.

 The `@` character adds a symbol to the label. See *Labels and Label Types*
 in the FLTK documentation.

 The pulldown menu offers some additional rendering styles for the label.

 \image html wp_gui_image.png
 \image latex wp_gui_image.png

 Add an image to the widget label here. The second row takes an optional image
 for rendering a deactivated widget.

 The image path must be relative to the location of the `.fl` file.
 The image data is inlined into the source code. If *compressed* is selected
 in the image properties field, the image is stored in its original format, and
 the fltk-images library must be linked to decompress at runtime.

 Images are stored at their original resolution. The image properties dialog
 provides *Scale* settings to scaled the image before rendering to screen.
 To make full use of high-dpi screen support, images should be stored at double
 resolution and then scaled to FLTK coordinates. This gives FLTK the chance to
 fall back to the full size image for high-dpi screens.

 \image html wp_gui_alignment.png
 \image latex wp_gui_alignment.png

 Control alignment of the label in relation to the widget position and size as
 well as the relation between the image and the label. The box on the right
 toggles between inside and outside label alignment.

 \image html wp_gui_size.png
 \image latex wp_gui_size.png

 Control the size and position of a widget here. The input fields react to
 vertical scroll wheel input for interactive positioning.

 All fields understand basic math. They are evaluated after the formula is
 entered and the result is stored in the respective properties. Formulas can
 also contain a number of variables. The *x* input can handle the variables
 `x` for its own position, `px` for the parent position, `sx` for the previous
 sibling, `cx` for the leftmost x position of all children, and `i`, which is a
 counter through all selected widgets.

 The formula `x+10` in the *x* field moves all selected widgets 10 pixels to
 the right. `100+25*i` in the *y* field arranges all widgets vertically
 starting at 100 with 25 pixels distance.

 \image html wp_gui_values.png
 \image latex wp_gui_values.png

 Activate for widgets that can take numerical values, these input fields take
 floating point numbers. The generate lines like `o->minimum(2);` only if the
 corresponding value differs from the default value for this property.

 \image html wp_gui_flexp.png
 \image latex wp_gui_flexp.png

 This row is only visible for children of `Fl_Flex` widgets. It sets the
 width or height of a widget in horizontal or vertical Flex widget. If *fixed*
 is unchecked, this value is instead calculated by the Flex.

 \image html wp_gui_margins.png
 \image latex wp_gui_margins.png

 This row is only visible for `Fl_Flex` widgets. It sets the various margins
 and the gap value for this widget.

 \image html wp_gui_sizerange.png
 \image latex wp_gui_sizerange.png

 This row is only visible for top level windows. The field sets the minimum
 and maximum size range for windows. Use the *set* button to copy the current
 size. Set width and height to `0` to disable that aspect of the size range.

 \image html wp_gui_shortcut.png
 \image latex wp_gui_shortcut.png

 This option is only visible for buttons and other widgets that can react to a
 shortcut key combination. FLUID does not check if a shortcut was already used
 elsewhere.

 If *shortcut use FL_COMMAND* is set in the project settings, modifiers are
 created in a more compatible way across platforms.

 \image html wp_gui_xclass.png
 \image latex wp_gui_xclass.png

 This row is only visible for top level windows. Note that selecting *modal*
 and *non modal* together is undefined.

 \image html wp_gui_attributes.png
 \image latex wp_gui_attributes.png

 Some additional attributes for all widget types. Activating *resizable* will
 add code to the parent widget to make this widget the resizable one of the
 parent group. Activating *hotspot* will add code to the parent window to make
 this widget the hotspot widget.

 \image html wp_gui_tooltip.png
 \image latex wp_gui_tooltip.png

 The *Tooltip* field can be any Unicode string and is stored as a static text.
 If internationalization is enabled, the corresponding modifiers are
 added.

 <!-- ---------------------------------------------------------------------- -->
 ## The Style Tab ##

 \image html wp_style_tab.png
 \image latex wp_style_tab.png

 The Style tab is used to edit font styles and size, and the color of elements
 of the widget.

 \image html wp_style_label.png
 \image latex wp_style_label.png

 \image html wp_style_text.png
 \image latex wp_style_text.png

 The font pulldown menu provides a list of standard fonts. To enter the index
 of a user loaded font, an *extra code* field must be used. The *label color*
 and *text color* fields opens a color palette selector. The arrow pulldown
 contains a list of the most commonly used colors. Again, user specific colors
 can be defined using the *extra code* field.

 The *Text Font* row is only available for widgets that contain an addition
 text area.

 \image html wp_style_box.png
 \image latex wp_style_box.png

 Select the up and down box for the give widget. The first six entries in the
 box and frame style list are influenced by the FLTK Scheme setting. Other
 box styles will always look the same, independently of the selected scheme.

 The *Down Box* row is only available for widgets that can be pressed down
 by the user.

 <!-- ---------------------------------------------------------------------- -->
 ## The C++ Tab ##

 \image html wp_cpp_tab.png
 \image latex wp_cpp_tab.png

 The C++ tab has various input field for adding C++ code at various places
 in the source and header file.

 \image html wp_cpp_class.png
 \image latex wp_cpp_class.png

 If the class property is set, FLUID assumes that the user wants to instantiate
 a widget that is derived from the selected widget. For a derived widget, the
 default values of attribute can not be known. FLUID will generate code to
 explicitly set every know attribute of the super class.

 If the selected widget is a Widget Class node, the Class property will instead
 set the super class of the widget.

 The pulldown menu on the right side contain additional subtypes for some
 widget types. `Fl_Button` widgets, for instance, can be further refined to
 be an `Fl_Toggle_Button` of an `Fl_Radio_Button`.

 \image html wp_cpp_name.png
 \image latex wp_cpp_name.png

 The name field can be any valid C++ variable name. If the widget is inside
 a class, the pulldown menu lets the user select between *private*, *protected*,
 and *public*. If not in the group, the variable can be *global* or *static*
 within the source file.

 \image html v_input.png
 \image latex v_input.png

 These four input fields can be used to add arbitrary code to different parts
 of the header and source file. A line can be divided into multiple lines
 of code by inserting a `Ctrl-J`.

 All Extra Code fields are interpreted individually. If a field contains a `#`
 character, or the words `extern`, `typedef`, or `using`, FLUID assumes that
 the code is a declaration and writes it to the header file, and only if it
 does not duplicate previously written code. This is great for creating a
 `#include "MyWidgetType.H"` include statement in the header.

 If the code is not recognized as a declaration, it will instead be put after
 the code that instantiates the widget and all its children. For menu items,
 the code is added after the container  `Fl_Menu_` is created, but before the
 menu array is added to the container.

 \image html wComment.png
 \image latex wComment.png

 Comments are added to the source code before the widget constructor by adding
 `// ` in front of every line of the comment. The first few characters of a
 comment are also visible in the widget browser in the main window.

 \image html wp_cpp_callback.png
 \image latex wp_cpp_callback.png

 The callback field can be interpreted in two ways. If the callback text is only
 a single word, FLUID assumes that this is the name of an external callback
 function and declares it in the header as
 `extern void my_button_action(Fl_Button*, void*);`.

 Otherwise, FLUID assumes that the text is the body of a C++ callback function
 and instead creates a local callback function. The name of the callback
 function is generated by FLUID and guaranteed to be unique within the file.
 ```
 static void cb_input(Fl_Input*, void*) {
   ... // my text from the Callback field here
 }
 ```

 The *User Data* field can contain any valid C++ code and is copied as the
 callback argument. *Type* is currently limited to `void*` and `long`.
 The *When* pulldown gives access to the `Fl_When` flags, including some
 commonly used combinations.

 <!-- ---------------------------------------------------------------------- -->
 ## The Grid Tab ##

 \image html wp_grid_tab.png
 \image latex wp_grid_tab.png

This tab is only available if the selected widget is an `Fl_Grid`. When editing
a Grid widget, no other widgets should be selected.

The *Grid Layout* field adjust the number of rows and columns in the grid.

The *Margin* fields describe the size of the margin around all children of
the grid.

The *Gaps* fields set the gaps between individual children in the grid.

The *Row* and *Column* groups can be used to set the size of individual rows
and columns within the grid.

 <!-- ---------------------------------------------------------------------- -->
 ## The Grid Child Tab ##

 \image html wp_gridc_tab.png
 \image latex wp_gridc_tab.png

This tab is only available if the selected widget is a child of an `Fl_Grid`.
When editing a child of a Grid widget, no other widgets should be selected.

Use the *Location* group to move a child around with in the grid. Note that
every cell in a grid can only manage one single widget. When moving widgets
over occupied cells, they become "transient". Just continue and move them into
an available cell. If a layout is saved with a transient widget, all grid
attributes for that widget are lost, and it will remain unassigned in the
project file and in the source code.

The *Align* fields provide a way to align a widget within its cell.

The *Min. Size* fields define a minimum width and height for the widget
in the cell.

The *Span* field change the number of cells that a widget can span in x and y.

\note Most attributes in this tab will also change the size of the widget. If
the child of the Grid is itself a group, the children of that group do not
follow changes in position or size. It is recommended to either lay out the
grid contents first and leave it unchanged, or to use widgets generated with
Widget Class that automatically adjust themselves to the size constraints
of the grid.

 <!-- ---------------------------------------------------------------------- -->
 <!-- ---------------------------------------------------------------------- -->

 \section appendix_code_nodes Functional Node Types

 ## Functions and Methods ##

 ![](flFunction.png) Functions and Methods

 Fluid can generate C functions, C++ functions, and methods in classes.
 Functions can contain widgets to build windows and dialogs. *Code* nodes can
 be used to add more source code to a function.

 ### Parents ###

 To generate a function, the function node must be created at the top level or
 inside a declaration block. If added inside a class node, this node generates
 a method inside that class.

 ### Children ###

 Function nodes can contain code nodes and widget trees. The topmost node of a
 widget tree must be a window.
 If the function node has no children, only a forward declaration will be
 created in the header, but no source code will be generated.

 \image html function_panel.png "Function/Method Properties"
 \image latex function_panel.png "Function/Method Properties"

 ### Declaring a Function ###

 A function node at the top level or inside a declaration block generates a C
 or C++ function.

 The *Name* field  contains the function name and all arguments.
 If the *Name* field is left empty, Fluid will generate a typical 'main()' function.
 ```
 // .cxx
 int main(int argc, char **argv) {
   // code generated by children
   w->show(argc, argv); // <-- code generated if function has a child widget
   Fl::run();
 }
 ```

 If a function node has a name but no children, a forward declaration is
 generated in the header, but the implementation in the source file is omitted.
 This is used to reference functions in other modules.
 ```
 // .h
 void make_window();
 ```

 If the function contains one or more Code nodes, the implementation code will
 be generated. The default return type is `void`. Text in the *Return Type* field
 overrides the default type.
 ```
 // .cxx
 void make_window() {
   // code generated by children
 }
 ```

 If the function contains a widget, a pointer to the first widget
 will be created. The default return type will match the type of the
 first widget, and a pointer to the widget will be returned.
 ```
 // .h
 Fl_Window* make_window();
 ```

 ```
 // .cxx
 Fl_Window* make_window() {
   Fl_Window* w;
   // code generated by children:
   // w = new Fl_Window(...)
   return w;
 }
 ```

 #### Options for Functions ####

 Choosing *static* in the pulldown menu will declare the function `static` in the
 source file. No prototype will be generated in the header.
 ```
 // .cxx
 static Fl_Window* make_window() { ... }
 ```

 If the *C* option is checked, the function will be declared as a plain C
 function in the header file.
 The options *local* and *C* together are not supported.
 ```
 // .h
 extern "C" { void my_plain_c_function(); }
 ```

 ### Declaring a Method ###

 A function node inside a class node generates a C++ method. If a method node has
 no children, the declaration is generated in the header, but no implementation
 in the source file.
 ```
 // .h
 class UserInterface {
 public:
   void make_window();
 };
 ```

 If the method contains one or more Code nodes, an implementation will also be
 generated.

 ```
 // .cxx
 void UserInterface::make_window() {
   printf("Hello, World!\n");
 }
 ```

 If the method contains at least on widget, a pointer to the topmost widget
 will be returned and the return type will be generated accordingly.
 ```
 // .h
 class UserInterface {
 public:
   Fl_Double_Window* make_window();
 };
 ```

 ```
 // .cxx
 Fl_Double_Window* UserInterface::make_window() {
   Fl_Double_Window* w;
   // code generated by children
   return w;
 }
 ```

 #### Options for Methods ####

 Class access can be defined with the pulldown menu. It provides a choice of
 `private`, `protected`, and `public`.

 Fluid recognizes the keyword `static` or `virtual` at the beginning of the
 *return type* and will generate the declaration including the keyword, but will
 omit it in the implementation. The return type defaults still apply if there
 is no text after the keyword.

 #### Further Options ####

 Users can define a comment text in the *comment* field. The first line of the
 comment will be shown in the widget browser. The comment text will be generated
 in the source file before the function.
 ```
 // .cxx
 //
 // My multilen comment will be here... .
 // Fluid may actually use C style comment markers.
 //
 Fl_Window* make_window() {
 ```

 Fluid recognizes default values in the argument list and geneartes them in the
 declaration, but omits them in the implementation.

 A short function body can be appended in the *Name* field. With no child, this
 creates an inlined function in the header file.

 <!-- ---------------------------------------------------------------------- -->

 ## C Source Code ##

 ![](flCode.png) Code

 Code nodes holds arbitrary C++ code that is copied verbatim into the
 source code file. They are commonly used inside Function nodes.

 ### Parents ###

 Code nodes can be added inside Functions, Code Blocks, and Widget Classes.

 \image html code_panel.png "Code Properties"
 \image latex code_panel.png "Code Properties"

 The Code Properties panel features a syntax-highlighting C++ code editor.
 Some basic bracket and braces match checking is done when closing the dialog.

 When inside a Function or Code Block, the C++ code is inserted directly.
 Inside a Widget Class, the code will be added to the constructor of the
 widget class.

 <!-- ---------------------------------------------------------------------- -->

 ## Code Block ##

 ![](flCodeBlock.png) Code Block

 Code Blocks are used when a single function generates different GUI elements
 conditionally.

 ### Parents ###

 Code Blocks are used inside functions and methods.

 ### Children ###

 Code Blocks can contain widgets, code, or more code blocks.

 \image html codeblock_panel.png "Code Block Properties"
 \image latex codeblock_panel.png "Code Block Properties"

 The two field expect the code before and after the `{ ... }` statements. The
 second field can be empty.

 Two consecutive Code Blocks can be used to generate `else`/`else if`
 statements by leaving the second field of the first node empty.

 <!-- ---------------------------------------------------------------------- -->

 ## Declaration ##

 ![](flDeclaration.png) Declaration

 ### Parents ###

 Declarations can be added at the top level or inside classes and widget classes.

 \image html decl_panel.png "Declaration Properties"
 \image latex decl_panel.png "Declaration Properties"

 Declaration nodes are quite flexible and can be a simple variable declaration
 such as `int i;`. But include statements are also allowed, as are type
 declarations, and comments. FLUID does its best to understand user intention,
 but the generated code should be verified by the user.

 Declarations nodes at the top level can selectively generate code in the header
 and /or in the source file. If a declaration is inside a class, the user can
 select if the class member is *private*, *protected*, or *public* instead.

 <!-- ---------------------------------------------------------------------- -->

 ## Declaration Block ##

 ![](flDeclarationBlock.png) Declaration Block

 Declaration Blocks are a way to selectively compile child nodes via
 preprocessor commands, typically `#ifdef TEST` and `#endif`.

 ### Parents ###

 Declaration Blocks can be created at the top level or inside classes.

 ### Children ###

 Declaration Blocks can contain classes, functions, methods, declarations, and
 comments.

 \image html declblock_panel.png "Declaration Block Properties"
 \image latex declblock_panel.png "Declaration Block Properties"

 Users can select if the block is generated in the source file only, or in the
 header file as well. The two input fields are used to enter the line of code
 before and after the child nodes. Two consecutive Declaration Blocks can be
 used to generate `#else`/`#elif` style code by leaving the second field of
 the first node empty.

 \note Declaration Blocks are not smart, and child nodes may still generate
 unexpected code outside the scope of this block. This may change in future
 versions of FLUID.

 <!-- ---------------------------------------------------------------------- -->

 ## Classes ##

![](flClass.png) Class

 FLUID can generate code to implement C++ classes. Classes can be used to keep
 dialogs and groups of UI elements organized. See Widget Class nodes as an
 alternative to implement compound widgets.

 ### Parents ###

 Class nodes can be created at top level or inside a Class or Widget
 Class node.

 ### Children ###

 Class nodes can contain Functions, Declarations, Widgets, Data, and
 other classes.

 \image html class_panel.png "Class Properties"
 \image latex class_panel.png "Class Properties"

 The *Name:* and *Subclass of:* fields should be set to standard C++ class
 names.

 Function nodes inside classes are implemented as methods. Constructors and
 destructors are recognized and implemented as such. Inlined data is declared
 as a static class member.

 Note that methods without a code or widget node are only declared in the
 header file, but no code is generated for them in the source file.

 <!-- ---------------------------------------------------------------------- -->

 ## Widget Class ##

 ![](flWidgetClass.png) Widget Class

 Widget Class node creates a new widget type by deriving a class from another
 widget class. These are often compound widgets derived from `Fl_Group`. A less
 automated but more flexible way to implement compound widgets is the Class node.

 ### Parents ###

 Widget Class nodes can be created at top level or inside a Class or Widget
 Class node.

 ### Children ###

 Widget Class nodes can contain Functions, Declarations, Widgets, Data, and
 other classes.

 ### Properties ###

 Widget Class nodes use the Widget panel to edit their properties. The super
 class can be set in the *C++* tab in the *Class* field. If that field is empty,
 FLUID derives from `Fl_Group`.

 The Widget Class always creates a constructor with the common widget parameters:
 ```
 MyWidget::MyWidget(int X, int Y, int W, int H, const char *L)
 : Fl_Group(X, Y, W, H, L) { ... }
 ```

 If the super class name contains the text `Window`, two more constructors
 and a common initializer method are created:
 ```
 MyWidget::MyWidget(int W, int H, const char *L) :
   Fl_Window(0, 0, W, H, L) { ... }

 MyWidget::MyWidget() :
   Fl_Window(0, 0, 480, 320, 0) { ... }

 void MyWidget::_MyWidget() { ... }
 ```

 Code and Widget nodes are then added to the constructor. Function nodes are
 added as methods to the class. Declarations are added as class members.
 Data nodes generate static class members.

 It may be useful to design compound widgets with a variable size. The Widget
 Panel provides a choice menu in the *GUI* tab's *Position* row under
 *Children*. The options *resize* and *reposition* generate code to fix up
 the coordinates of the widget after instantiation.

 Note that methods without a code or widget node are only declared in the
 header file, but no code is generated for them in the source file.

 <!-- ---------------------------------------------------------------------- -->

 ## Comments ##

 ![](flComment.png) Comment

 This node adds a comment block to the generated source code.

 ### Parents ###

 Comment nodes can be added inside Functions, Code Blocks, and Widget Classes.
 If a Comment node is the top node in a tree, it will appear in the source
 files even before the `// generated by FLUID ...` line.

 \image html comment_panel.png "Comment Properties"
 \image latex comment_panel.png "Comment Properties"

 Comment blocks are generated by adding `// ` to the start of each line unless
 the first line of a comment starts with `/``*`. In that case, FLUID assumes
 a correct block comment and will copy the text verbatim.

 Comments can be generated in the header file, the source file, or both.

 FLUID keeps a small database of predefined comments. Users can add reoccurring
 comment blocks, license information for example, to this database via the
 pulldown menu.

 Comments can also be imported from an external file.

 <!-- ---------------------------------------------------------------------- -->

 ## Inlined Data ##

 ![](flData.png) Inlined Data

 The Data node makes it easy to inline data from an external file into the
 source code.

 ### Parents ###

 Data nodes can be added at the top level or inside Widget Classes, Classes,
 and Declaration Blocks.

 \image html data_panel.png "Data Properties"
 \image latex data_panel.png "Data Properties"

 At top level, or inside a Declaration Block, Data can be declared *in source
 file only*, *static in source file*, or *in source and extern in header*.

 If Data is inside a Class node, it is always declared `static`. The user can
 select *private*, *protected*, or *public*.

 Data in binary mode will be stored in an `unsigned char` array. The data size
 can be queried with `sizeof()`. In Text mode, it will be stored as `const
 char*` and terminated with a `NUL` character.

 In compressed mode, data will be compressed with zlib `compress()` and stored
 in an `unsigned char` array. A second variable, holding the original data size,
 is declared `int` by appending `_size` to the variable name.

 ```
 // .cxx
 int myInlineData_size = 12034;
 unsigned char myInlineData[380] = { 65, 128, ... };
 ```

 The Variable Name should be a regular C++ name. The Filename field expects
 the path and name of a file, relative to the location of the .fl file.

 <!-- ---------------------------------------------------------------------- -->

 \section appendix_app_settings Fluid Application Settings

 ## Options ##

 __Select scheme__ : select a scheme for Fluid. Changes in the scheme will be
 visible instantly in all windows.

 __Show tooltips__ : if checked, show tooltips for most UI elements in Fluid dialogs.

 __Show completions dialogs__ : if checked, Fluid will pop up a dialog box
 after generating code, header, and strings files.

 __Open previous file on startup__ : when launching Fluid in its interactive
 mode, it will load the file that was last open when Fluid was closed.

 __Remember window positions__ : reopen windows and dialogs where they were
 left when Fluid was last closed.

 __Show comments in browser__ : if a comment has been specified for a type, show
 the initial line of the comment within the widget tree browser.

 ## External Editor ##

 When you configure the External Editor text field with a shell command and
 select the "Use for Code Nodes" option, FLUID will launch an external editor
 for editing the C++ code within a Code Node. After making changes and saving
 the code in the external editor, it will automatically be transferred back
 into the Code Node. The shell command is constructed by combining the text
 field's content with the path and name of a temporary file containing the
 code snippet. The file name ends in `.cxx`.

 ## Overlays ##

 __Show positioning guides__ :

 When enabled, FLUID will use the existing Layout settings to propose widget
 positions and dimensions that align with other widgets within the project.
 It displays red indicator guides on the scene to illustrate the widget's
 relationship with its neighboring elements. If you drag the widgets with the
 mouse, they will automatically align with these preferred positions.

 __Show restricted areas__ :

 When selected, FLUID will display a hash pattern when widgets overlap with
 other widgets within the same group or extend beyond the boundaries of their
 parent group. Widgets that are invisible will not trigger this effect.

 __Ghosting low contrast groups__ :

 Occasionally, newly created groups can be inconspicuous during the editing
 process when their background matches that of the parent and no visible
 box is drawn. However, if you enable the "Show Low Contrast Groups Ghosted"
 option, groups that lack a box type or have a flat box type with the same
 color as the parent will be displayed with a faint outline
 in the editing window.

 During live resizing and after project compilation, all groups will be
 rendered as originally designed, without the ghosted outline.

 */
