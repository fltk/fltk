/**

 \page advanced Advanced FLTK

This chapter explains advanced programming and design topics
that will help you to get the most out of FLTK.

<A NAME="multithreading"> </A> <!-- For old HTML links only ! -->
\section advanced_multithreading Multithreading

FLTK supports multithreaded application using a locking mechanism
based on "pthreads". We do not provide a threading interface as part of
the library.  However a simple example how threads can be implemented
for all supported platforms can be found in \p test/threads.h
and \p test/threads.cxx.

To use the locking mechanism, FLTK must be compiled with
\p --enable-threads set during the \p configure
process. IDE-based versions of FLTK are automatically compiled with
locking enabled if possible.

In \p main(), call
Fl::lock() before
Fl::run() or
Fl::wait() to start the runtime
multithreading support for your program. All callbacks and derived
functions like \p handle() and \p draw() will now be properly
locked:

\code
    int main() {
      Fl::lock();
      /* run thread */
      while (Fl::wait() &gt; 0) {
        if (Fl::thread_message()) {
          /* process your data */
        }
      }
    }
\endcode

You can now start as many threads as you like. From within
a thread (other than the main thread) FLTK calls must be wrapped
with calls to Fl::lock() and Fl::unlock():

\code
    Fl::lock();      // avoid conflicting calls
    ...              // your code here
    Fl::unlock();    // allow other threads to access FLTK again
\endcode

You can send messages from child threads to the main thread 
using Fl::awake(void* message):

\code
    void *msg;       // "msg" is a pointer to your message
    Fl::awake(msg);  // send "msg" to main thread
\endcode

You can also tell the main thread to call a function for you
as soon as possible by using
Fl::awake(Fl_Awake_Handler cb, void* userdata):

\code
    void do_something(void *userdata) {
      // running with the main thread
    }

    // running in another thread
    void *data;       // "data" is a pointer to your user data
    Fl::awake(do_something, data);  // call something in main thread
\endcode

      
FLTK supports multiple platforms, some of them which do not 
allow any other but the main thread to handle system events and
open or close windows. The safe thing to do is to adhere to the 
following rules for threads on all operating systems:


\li Don't \p show() or \p hide() anything that contains 
    widgets derived from Fl_Window, including dialogs, file
    choosers, subwindows or Fl_Gl_Window's

\li Don't call Fl::wait(), Fl::flush() or any 
    related methods that will handle system messages

\li Don't start or cancel timers

\li Don't change window decorations or titles

\li The \p make_current() method may or may not work well for
    regular windows, but should always work for Fl_Gl_Window's
    to allow for high speed rendering on graphics cards with multiple
    pipelines

See also: 
Fl::awake(void* message),
Fl::lock(),
Fl::thread_message(),
Fl::unlock().

\htmlonly
<hr>
<a class="el" href="index.html">[Index]</a> &nbsp;&nbsp;
<a class="el" href="fluid.html">[Previous]&nbsp; Programming with FLUID</a>&nbsp;
<a class="el" href="unicode.html">[Next]&nbsp; Unicode and utf-8 Support</a>&nbsp;
\endhtmlonly
*/
